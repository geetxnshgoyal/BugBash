<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Team Dashboard • Bug Bash</title>
<link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"/>
<meta name="robots" content="noindex,nofollow"/>
<style>
  :root{
    --bg1:#0f1720;--bg2:#0b1020;
    --glass:rgba(255,255,255,0.06);--glass2:rgba(255,255,255,0.03);
    --accent:#7be04a;--accent-soft:rgba(123,224,74,0.18);
    --muted:#94a3b8;--danger:#f87171;--warning:#facc15;
    --white:#f8fafc;--shadow:0 18px 44px rgba(2,8,23,0.6);
    --font:'Segoe UI',Roboto,Helvetica,system-ui,sans-serif;
    --badge-bg:rgba(148,163,184,0.16);--badge-color:#e2e8f0;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    min-height:100vh;
    font-family:var(--font);
    color:var(--white);
    background:
      radial-gradient(1200px 600px at 10% 10%,rgba(123,224,74,0.05),transparent),
      linear-gradient(180deg,var(--bg1),var(--bg2));
    position:relative;
    overflow-x:hidden;
  }
  #bg-canvas{
    position:fixed;
    inset:0;
    z-index:0;
    pointer-events:none;
    opacity:.65;
    mix-blend-mode:screen;
  }
  a{color:var(--accent)}
  .wrap{
    max-width:1200px;
    margin:0 auto;
    padding:32px 20px 80px;
    position:relative;
    z-index:2;
  }
  header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:18px;
    margin-bottom:28px;
  }
  .brand{font-size:22px;font-weight:800;letter-spacing:.6px;color:var(--white);text-decoration:none;display:inline-flex;align-items:center;gap:6px}
  .brand span{color:var(--accent)}
  .nav-actions{
    display:flex;
    gap:12px;
    align-items:center;
  }
  .nav-actions a{
    color:var(--muted);
    text-decoration:none;
    font-size:14px;
  }
  .panel{
    background:linear-gradient(180deg,var(--glass),transparent);
    border-radius:18px;
    padding:28px;
    box-shadow:var(--shadow);
    backdrop-filter:blur(6px);
    opacity:0;
    transform:translateY(18px);
    transition:opacity .5s ease,transform .5s ease;
  }
  .panel.is-visible{
    opacity:1;
    transform:translateY(0);
  }
  .dashboard[hidden], .meme-panel[hidden]{display:none !important;}
  h1{margin:0 0 16px;font-size:28px}
  h2{margin:0;font-size:22px}
  .muted{color:var(--muted);margin:0 0 18px;font-size:15px}
  label{display:flex;flex-direction:column;gap:6px;margin-bottom:16px;font-size:14px;color:var(--muted)}
  input,select,textarea{
    padding:12px 14px;
    border-radius:10px;
    border:1px solid rgba(148,163,184,0.28);
    background:var(--glass2);
    color:var(--white);
    font:inherit;
  }
  input:focus,select:focus,textarea:focus{
    outline:2px solid var(--accent);
    outline-offset:2px;
  }
  button{
    border:none;
    border-radius:999px;
    padding:12px 20px;
    font:inherit;
    font-weight:600;
    cursor:pointer;
    background:var(--accent);
    color:#041007;
    transition:transform .15s ease,box-shadow .15s ease;
  }
  button:hover{transform:translateY(-1px);box-shadow:0 8px 20px rgba(123,224,74,0.35)}
  button:disabled{opacity:.6;cursor:not-allowed;box-shadow:none;transform:none}
  .btn-ghost{
    background:transparent;
    color:var(--muted);
    border:1px solid rgba(148,163,184,0.3);
    padding:10px 18px;
  }
  .layout{
    display:grid;
    gap:24px;
  }
  .dashboard{
    display:grid;
    gap:24px;
  }
  .dashboard-header{
    display:flex;
    flex-wrap:wrap;
    gap:20px;
    align-items:center;
    justify-content:space-between;
  }
  .meme-panel{
    margin:10px 0 24px;
    padding:18px 22px;
    border-radius:16px;
    background:rgba(15,23,42,0.6);
    border:1px solid rgba(148,163,184,0.22);
    display:flex;
    flex-direction:column;
    gap:12px;
    opacity:0;
    transform:translateY(12px);
    transition:opacity .28s ease,transform .28s ease;
  }
  .meme-panel.is-visible{opacity:1;transform:translateY(0);}
  .meme-panel h3{
    margin:0;
    font-size:16px;
    letter-spacing:.3px;
    color:var(--accent);
  }
  .meme-panel p{
    margin:0;
    color:#cbd5f5;
    font-size:14px;
    line-height:1.5;
  }
  .meme-panel .meme-footer{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:10px;
    font-size:12px;
    color:var(--muted);
  }
  .member-card{
    padding:18px 22px;
    border-radius:16px;
    background:var(--glass2);
    border:1px solid rgba(148,163,184,0.18);
    min-width:260px;
  }
  .member-card h3{margin:0 0 6px;font-size:18px}
  .member-meta{margin:0;font-size:14px;color:var(--muted)}
  .stats{
    display:flex;
    gap:14px;
    flex-wrap:wrap;
  }
  .stat-pill{
    background:var(--glass2);
    border-radius:14px;
    padding:14px 18px;
    border:1px solid rgba(148,163,184,0.18);
    min-width:140px;
  }
  .stat-pill strong{display:block;font-size:20px;color:var(--accent)}
  .task-section,.event-section{
    background:var(--glass2);
    border-radius:18px;
    border:1px solid rgba(148,163,184,0.18);
    padding:24px;
  }
  .section-header{
    display:flex;
    flex-wrap:wrap;
    gap:14px;
    justify-content:space-between;
    align-items:center;
    margin-bottom:18px;
  }
  .filters{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    align-items:center;
  }
  .filters label.inline{
    display:inline-flex;
    align-items:center;
    gap:6px;
    margin:0;
    color:var(--muted);
    font-size:13px;
  }
  .badge{
    display:inline-flex;
    align-items:center;
    gap:6px;
    background:var(--badge-bg);
    color:var(--badge-color);
    padding:4px 10px;
    border-radius:999px;
    font-size:12px;
    text-transform:uppercase;
    letter-spacing:.6px;
  }
  .badge.status-todo{background:rgba(148,163,184,0.18);color:#f1f5f9}
  .badge.status-in_progress{background:rgba(59,130,246,0.18);color:#60a5fa}
  .badge.status-blocked{background:rgba(248,113,113,0.18);color:#fca5a5}
  .badge.status-done{background:rgba(94,234,212,0.18);color:#5eead4}
  .task-list{
    display:grid;
    gap:16px;
  }
  .task-card{
    position:relative;
    border-radius:16px;
    border:1px solid rgba(148,163,184,0.18);
    background:linear-gradient(180deg,var(--glass),transparent);
    padding:20px;
    --task-accent: var(--accent);
    border-left:6px solid var(--task-accent);
    transition:box-shadow .18s ease,transform .18s ease,opacity .28s ease;
    opacity:0;
    transform:translateY(18px);
  }
  .task-card--show{opacity:1;transform:translateY(0);}
  .task-card::after{
    content:'';
    position:absolute;
    inset:0;
    border-radius:16px;
    pointer-events:none;
    border:1px solid rgba(123,224,74,0);
    transition:border .18s ease;
  }
  .task-card--mine{
    box-shadow:0 0 0 1px var(--task-accent),0 18px 30px rgba(123,224,74,0.18);
    transform:translateY(-1px);
  }
  .task-card--mine::after{
    border-color:rgba(123,224,74,0.25);
  }
  .task-card--unassigned{
    border-style:dashed;
  }
  .task-card h3{
    margin:0 0 10px;
    font-size:18px;
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:10px;
  }
  .task-badges{
    display:flex;
    gap:6px;
    flex-wrap:wrap;
    justify-content:flex-end;
  }
  .task-card p{margin:6px 0 12px;font-size:14px;color:var(--muted)}
  .task-team-tag{
    display:inline-flex;
    align-items:center;
    gap:6px;
    font-size:12px;
    padding:4px 10px;
    border-radius:999px;
    border:1px solid currentColor;
    color:var(--task-accent);
    background:rgba(255,255,255,0.04);
    margin-bottom:10px;
    text-transform:uppercase;
    letter-spacing:.5px;
  }
  .task-meta{
    display:flex;
    flex-wrap:wrap;
    gap:12px;
    font-size:13px;
    color:var(--muted);
  }
  .task-meta span strong{color:var(--white)}
  .task-actions{
    display:flex;
    gap:12px;
    flex-wrap:wrap;
    margin-top:14px;
  }
  .task-actions button{
    padding:8px 16px;
    font-size:13px;
  }
  .status-menu{
    position:absolute;
    z-index:40;
    min-width:180px;
    background:rgba(15,23,42,0.95);
    border:1px solid rgba(123,224,74,0.18);
    border-radius:12px;
    padding:6px;
    display:flex;
    flex-direction:column;
    gap:4px;
    box-shadow:0 18px 40px rgba(2,8,23,0.5);
    backdrop-filter:blur(10px);
  }
  .status-menu__item{
    border:none;
    background:transparent;
    color:var(--white);
    text-align:left;
    padding:8px 12px;
    border-radius:8px;
    font:inherit;
    cursor:pointer;
    transition:background .18s ease,color .18s ease;
  }
  .status-menu__item:hover,
  .status-menu__item:focus{
    background:rgba(123,224,74,0.18);
    color:var(--accent);
    outline:none;
  }
  .status-menu__item.is-active{
    background:rgba(123,224,74,0.24);
    color:var(--accent);
    font-weight:600;
  }
  .task-owners{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
    margin-top:6px;
  }
  .owner-chip{
    background:rgba(148,163,184,0.16);
    border-radius:999px;
    padding:4px 10px;
    font-size:12px;
    color:#e2e8f0;
  }
  .badge.badge--warn{
    background:rgba(250,204,21,0.16);
    color:#fde68a;
  }
  .assignment-hint{
    margin:10px 0 0;
    font-size:13px;
    color:#e2e8f0;
  }
  .task-last-update{
    margin-top:12px;
    font-size:13px;
    color:var(--muted);
  }
  .task-last-update strong{
    color:var(--white);
  }
  .task-actions button{
    padding:8px 16px;
    font-size:13px;
  }
  details.task-updates{
    margin-top:14px;
    border-top:1px solid rgba(148,163,184,0.16);
    padding-top:12px;
  }
  details.task-updates summary{
    cursor:pointer;
    font-size:13px;
    color:var(--muted);
    display:flex;
    align-items:center;
    gap:6px;
    transition:color .2s ease;
  }
  details.task-updates summary::before{
    content:'▸';
    font-size:12px;
    transition:transform .2s ease;
  }
  details.task-updates[open] summary::before{transform:rotate(90deg);}
  details.task-updates[open] summary{color:var(--accent);}
  .updates-list{
    margin-top:10px;
    display:grid;
    gap:10px;
    opacity:0;
    transform:translateY(-6px);
    transition:opacity .25s ease,transform .25s ease;
  }
  details.task-updates[open] .updates-list{
    opacity:1;
    transform:translateY(0);
  }
  .update-pill{
    background:rgba(15,23,42,0.55);
    border-radius:12px;
    padding:10px 12px;
    border:1px solid rgba(148,163,184,0.14);
    font-size:13px;
  }
  .update-pill strong{display:block;color:var(--white);margin-bottom:4px}
  .events-list{
    display:grid;
    gap:14px;
  }
  .event-card{
    border-radius:14px;
    border:1px solid rgba(148,163,184,0.16);
    background:rgba(15,23,42,0.55);
    padding:16px 18px;
    opacity:0;
    transform:translateY(12px);
    transition:opacity .28s ease,transform .28s ease;
  }
  .event-card--show{opacity:1;transform:translateY(0);}
  .event-card h4{margin:0 0 6px;font-size:16px}
  .event-card p{margin:4px 0;font-size:13px;color:var(--muted)}
  .status-message{
    margin-top:12px;
    font-size:14px;
    color:var(--muted);
  }
  .status-message.error{color:var(--danger)}
  .status-message.success{color:var(--accent)}
  @media(max-width:960px){
    .dashboard{gap:18px}
    .task-section,.event-section{padding:20px}
  }
  @media(min-width:900px){
    .dashboard-main{
      display:grid;
      grid-template-columns:minmax(0,2fr) minmax(0,1fr);
      gap:20px;
      align-items:start;
    }
  }
  @media(prefers-reduced-motion:reduce){
    *,*::before,*::after{
      animation-duration:.01ms!important;
      animation-iteration-count:1!important;
      transition-duration:.01ms!important;
      scroll-behavior:auto!important;
    }
  }
</style>
</head>
<body>
<canvas id="bg-canvas"></canvas>
<div class="wrap">
  <header>
    <a class="brand" href="/">BUG BASH <span>Team</span></a>
    <div class="nav-actions">
      <a href="/register">Registration</a>
      <a href="/admin">Admin</a>
    </div>
  </header>

  <main class="layout">
    <section class="panel" id="loginPanel">
      <h1>Team Dashboard</h1>
      <p class="muted">Private workspace for NST organizers. Sign in with your name and the latest password.</p>
      <form id="loginForm" autocomplete="off">
        <label>Name
          <input type="text" name="identifier" required placeholder="Enter your name" autocomplete="off" pattern="[A-Za-z ]+" title="Use letters and spaces only">
        </label>
        <label>Password
          <input type="password" name="code" required placeholder="Password">
        </label>
        <button type="submit" id="loginSubmit">Sign in</button>
      </form>
      <p id="loginMessage" class="status-message" hidden></p>
    </section>

    <section class="dashboard" id="dashboardPanel" hidden>
      <div class="dashboard-header">
        <div class="member-card" id="memberCard">
          <h3 id="memberName"></h3>
          <p class="member-meta" id="memberMeta"></p>
        </div>
        <div class="stats" id="statsRow"></div>
        <div class="nav-actions">
          <button class="btn-ghost" id="refreshBtn">Refresh</button>
          <button class="btn-ghost" id="logoutBtn">Sign out</button>
        </div>
      </div>

      <section class="meme-panel" id="memePanel" hidden>
        <h3>🎉 Meme of the Sprint</h3>
        <p id="memeText"></p>
        <div class="meme-footer">
          <span id="memeAttribution"></span>
          <button class="btn-ghost" id="memeShuffle" type="button">New meme</button>
        </div>
      </section>

      <p id="dashboardStatus" class="status-message" hidden></p>

      <div class="dashboard-main">
        <div class="task-section">
          <div class="section-header">
            <h2>Tasks</h2>
            <div class="filters">
              <select id="departmentFilter">
                <option value="mine">My team</option>
                <option value="all">All teams</option>
              </select>
              <select id="statusFilter">
                <option value="all">All statuses</option>
                <option value="todo">To do</option>
                <option value="in_progress">In progress</option>
                <option value="blocked">Blocked</option>
                <option value="done">Completed</option>
              </select>
              <label class="inline">
                <input type="checkbox" id="myTasksToggle">
                Assigned to me
              </label>
              <button id="newTaskBtn" hidden>Create task</button>
            </div>
          </div>
          <div class="task-list" id="taskList"></div>
        </div>

        <aside class="event-section">
          <div class="section-header">
            <h2>Upcoming</h2>
          </div>
          <div class="events-list" id="eventList"></div>
        </aside>
      </div>
    </section>
  </main>
</div>

<script>
(() => {
  const canvas = document.getElementById('bg-canvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  let width = (canvas.width = window.innerWidth);
  let height = (canvas.height = window.innerHeight);
  const particles = [];
  const pulses = [];

  const random = (min, max) => Math.random() * (max - min) + min;

  const paintStatic = () => {
    const gradient = ctx.createLinearGradient(0, 0, width, height);
    gradient.addColorStop(0, 'rgba(11,16,32,0.18)');
    gradient.addColorStop(1, 'rgba(2,8,18,0.22)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);
  };

  const rebuildParticles = () => {
    particles.length = 0;
    pulses.length = 0;
    const particleCount = Math.max(40, Math.floor((width * height) / 70000));
    for (let i = 0; i < particleCount; i++) {
      particles.push({
        x: random(0, width),
        y: random(0, height),
        r: random(0.6, 2.6),
        vx: random(-0.4, 0.6),
        vy: random(-0.3, 0.4)
      });
    }
    const pulseCount = Math.max(5, Math.floor(width / 280));
    for (let i = 0; i < pulseCount; i++) {
      pulses.push({
        x: random(0, width),
        y: random(0, height),
        radius: random(20, 70),
        alpha: random(0.04, 0.16),
        speed: random(0.3, 0.55)
      });
    }
  };

  const resetPulse = (pulse) => {
    pulse.x = random(0, width);
    pulse.y = random(0, height);
    pulse.radius = random(16, 60);
    pulse.alpha = random(0.04, 0.14);
    pulse.speed = random(0.28, 0.52);
  };

  const resize = () => {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    if (prefersReduced) {
      paintStatic();
    } else {
      rebuildParticles();
    }
  };
  window.addEventListener('resize', resize);

  if (prefersReduced) {
    paintStatic();
    return;
  }

  rebuildParticles();

  const draw = () => {
    ctx.clearRect(0, 0, width, height);
    paintStatic();

    for (const pulse of pulses) {
      pulse.radius += pulse.speed;
      pulse.alpha -= 0.0014;
      if (pulse.alpha <= 0) {
        resetPulse(pulse);
      }
      const gradient = ctx.createRadialGradient(pulse.x, pulse.y, 0, pulse.x, pulse.y, pulse.radius);
      gradient.addColorStop(0, `rgba(123,224,74,${pulse.alpha})`);
      gradient.addColorStop(1, 'rgba(123,224,74,0)');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(pulse.x, pulse.y, pulse.radius, 0, Math.PI * 2);
      ctx.fill();
    }

    for (const particle of particles) {
      particle.x += particle.vx;
      particle.y += particle.vy;
      if (particle.x < -20) particle.x = width + 20;
      if (particle.x > width + 20) particle.x = -20;
      if (particle.y < -20) particle.y = height + 20;
      if (particle.y > height + 20) particle.y = -20;

      ctx.beginPath();
      ctx.fillStyle = `rgba(123,224,74,${0.06 + particle.r / 7})`;
      ctx.shadowColor = 'rgba(123,224,74,0.2)';
      ctx.shadowBlur = 6;
      ctx.arc(particle.x, particle.y, particle.r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.shadowBlur = 0;

    const limit = Math.min(particles.length, 120);
    for (let i = 0; i < limit; i++) {
      const a = particles[i];
      for (let j = i + 1; j < limit; j++) {
        const b = particles[j];
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        const distSq = dx * dx + dy * dy;
        if (distSq < 7800) {
          ctx.beginPath();
          ctx.strokeStyle = `rgba(123,224,74,${0.004 + (7800 - distSq) / 10000})`;
          ctx.lineWidth = 0.7;
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();
        }
      }
    }

    requestAnimationFrame(draw);
  };

  draw();
})();
</script>

<script>
(() => {
  const state = {
    token: null,
    member: null,
    department: null,
    stats: {},
    tasks: [],
    events: [],
    filters: {
      showMine: false,
      status: 'all',
      department: 'mine'
    },
    people: new Map()
  };
  let lastMemeIndex = -1;

  const els = {
    loginPanel: document.getElementById('loginPanel'),
    dashboardPanel: document.getElementById('dashboardPanel'),
    loginForm: document.getElementById('loginForm'),
    loginSubmit: document.getElementById('loginSubmit'),
    loginMessage: document.getElementById('loginMessage'),
    memberName: document.getElementById('memberName'),
    memberMeta: document.getElementById('memberMeta'),
    statsRow: document.getElementById('statsRow'),
    dashboardStatus: document.getElementById('dashboardStatus'),
    taskList: document.getElementById('taskList'),
    eventList: document.getElementById('eventList'),
    logoutBtn: document.getElementById('logoutBtn'),
    refreshBtn: document.getElementById('refreshBtn'),
    departmentFilter: document.getElementById('departmentFilter'),
    myTasksToggle: document.getElementById('myTasksToggle'),
    statusFilter: document.getElementById('statusFilter'),
    newTaskBtn: document.getElementById('newTaskBtn'),
    memePanel: document.getElementById('memePanel'),
    memeText: document.getElementById('memeText'),
    memeAttribution: document.getElementById('memeAttribution'),
    memeShuffle: document.getElementById('memeShuffle')
  };

  const identifierInput = els.loginForm?.querySelector('input[name="identifier"]');
  if (identifierInput) {
    identifierInput.addEventListener('input', () => {
      const sanitized = identifierInput.value
        .replace(/[^A-Za-z\s]/g, '')
        .replace(/\s+/g, ' ')
        .replace(/^\s+/, '');
      if (sanitized !== identifierInput.value) {
        identifierInput.value = sanitized;
      }
    });
  }

  if (els.statusFilter) {
    els.statusFilter.value = state.filters.status;
  }
  if (els.myTasksToggle) {
    els.myTasksToggle.checked = state.filters.showMine;
  }

  const indexPerson = (person) => {
    if (!person || typeof person !== 'object' || !person.id) return;
    state.people.set(person.id, {
      id: person.id,
      displayName: person.displayName || person.name || '',
      email: person.email || '',
      role: person.role || '',
      loginId: person.loginId || '',
      departmentId: person.departmentId || ''
    });
  };

  const lookupPerson = (id) => {
    if (!id) return null;
    return state.people.get(id) || null;
  };

  const escapeHTML = (value = '') =>
    String(value)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');

  const getMemberRole = () =>
    (state.member?.roleNormalized || state.member?.role || '').toLowerCase();

  const isElevatedMember = () => {
    const role = getMemberRole();
    return role === 'lead' || role === 'mentor';
  };

  const STATUS_OPTIONS = [
    { value: 'todo', label: 'To do' },
    { value: 'in_progress', label: 'In progress' },
    { value: 'blocked', label: 'Blocked' },
    { value: 'done', label: 'Completed' }
  ];

  let statusMenuEl = null;
  let statusMenuAnchor = null;
  let statusMenuOutsideHandler = null;
  let statusMenuKeyHandler = null;

  const closeStatusMenu = () => {
    if (statusMenuOutsideHandler) {
      document.removeEventListener('click', statusMenuOutsideHandler, true);
      statusMenuOutsideHandler = null;
    }
    if (statusMenuKeyHandler) {
      document.removeEventListener('keydown', statusMenuKeyHandler, true);
      statusMenuKeyHandler = null;
    }
    if (statusMenuEl) {
      statusMenuEl.remove();
      statusMenuEl = null;
    }
    statusMenuAnchor = null;
  };

  const openStatusMenu = (anchorEl, task) => {
    if (!anchorEl || !task) return;
    closeStatusMenu();
    statusMenuAnchor = anchorEl;
    const menu = document.createElement('div');
    menu.className = 'status-menu';
    menu.setAttribute('role', 'menu');
    menu.tabIndex = -1;
    STATUS_OPTIONS.forEach((option) => {
      const item = document.createElement('button');
      item.type = 'button';
      item.className = 'status-menu__item';
      item.dataset.value = option.value;
      if (option.value === task.status) {
        item.classList.add('is-active');
      }
      item.textContent = option.label;
      item.addEventListener('click', async (evt) => {
        evt.preventDefault();
        evt.stopPropagation();
        closeStatusMenu();
        if (option.value === task.status) {
          return;
        }
        try {
          await fetchJSON(`/api/team/tasks/${encodeURIComponent(task.id)}`, {
            method: 'PATCH',
            body: JSON.stringify({ status: option.value })
          });
          setStatus('Task status updated.', 'success');
          await refreshProfile();
          await refreshTasks();
        } catch (err) {
          const errorCode = err.payload?.error || 'update_failed';
          const messages = {
            forbidden: 'You do not have permission to update the status.',
            invalid_status: 'Status must be todo, in_progress, blocked, or done.',
            update_failed: 'Could not update task.'
          };
          setStatus(messages[errorCode] || 'Could not update task.', 'error');
        }
      });
      menu.appendChild(item);
    });
    menu.addEventListener('click', (evt) => evt.stopPropagation());
    menu.style.opacity = '0';
    document.body.appendChild(menu);
    const anchorRect = anchorEl.getBoundingClientRect();
    const menuRect = menu.getBoundingClientRect();
    let left = anchorRect.left + window.scrollX;
    let top = anchorRect.bottom + window.scrollY + 8;
    const maxLeft = window.scrollX + window.innerWidth - menuRect.width - 16;
    const minLeft = window.scrollX + 16;
    if (left > maxLeft) left = Math.max(minLeft, maxLeft);
    if (left < minLeft) left = minLeft;
    const maxTop = window.scrollY + window.innerHeight - menuRect.height - 16;
    const aboveTop = anchorRect.top + window.scrollY - menuRect.height - 8;
    if (top > maxTop) {
      top = Math.max(window.scrollY + 16, aboveTop);
    }
    menu.style.left = `${left}px`;
    menu.style.top = `${top}px`;
    menu.style.opacity = '1';
    statusMenuEl = menu;
    statusMenuOutsideHandler = (evt) => {
      if (!statusMenuEl) return;
      if (statusMenuEl.contains(evt.target) || evt.target === statusMenuAnchor) {
        return;
      }
      closeStatusMenu();
    };
    document.addEventListener('click', statusMenuOutsideHandler, true);
    statusMenuKeyHandler = (evt) => {
      if (evt.key === 'Escape') {
        closeStatusMenu();
      }
    };
    document.addEventListener('keydown', statusMenuKeyHandler, true);
    menu.focus({ preventScroll: true });
  };

  window.addEventListener('scroll', closeStatusMenu, true);
  window.addEventListener('resize', closeStatusMenu, true);

  const MEMES = [
    {
      text: 'Deploying on Fridays? That’s a plot twist, not a roadmap.',
      author: 'Bug Bash Ops'
    },
    {
      text: 'Remember: coffee is just hot bug triage fuel ☕️',
      author: 'Hackathon Pantry Team'
    },
    {
      text: 'QA said “LGTM”, which obviously stands for “Let’s Get The Memes.”',
      author: 'Sprint Standup'
    },
    {
      text: 'If at first you don’t succeed, clear cache, drink chai, try again.',
      author: 'The Dev Shrine'
    },
    {
      text: 'Our CI pipeline now includes 30% more memes to catch flaky spirits.',
      author: 'Automation Squad'
    }
  ];

  const pickRandomMeme = () => {
    let index = Math.floor(Math.random() * MEMES.length);
    if (index === lastMemeIndex && MEMES.length > 1) {
      index = (index + 1) % MEMES.length;
    }
    lastMemeIndex = index;
    return MEMES[index];
  };

  const renderMeme = () => {
    if (!els.memePanel || !els.memeText || !els.memeAttribution) return;
    const meme = pickRandomMeme();
    els.memeText.textContent = meme.text;
    els.memeAttribution.textContent = meme.author ? `— ${meme.author}` : '';
    els.memePanel.hidden = false;
    requestAnimationFrame(() => els.memePanel.classList.add('is-visible'));
  };

  const reveal = (element) => {
    if (!element) return;
    element.classList.remove('is-visible');
    // Force reflow so animation restarts
    void element.offsetWidth;
    requestAnimationFrame(() => element.classList.add('is-visible'));
  };

  const setToken = (token) => {
    state.token = token;
  };

  const clearStatus = () => {
    els.dashboardStatus.hidden = true;
    els.dashboardStatus.textContent = '';
    els.dashboardStatus.classList.remove('error', 'success');
  };

  const setStatus = (text, type = '') => {
    if (!text) {
      clearStatus();
      return;
    }
    els.dashboardStatus.hidden = false;
    els.dashboardStatus.textContent = text;
    els.dashboardStatus.classList.remove('error', 'success');
    if (type) {
      els.dashboardStatus.classList.add(type);
    }
  };

  const showLogin = (message) => {
    els.dashboardPanel.hidden = true;
    els.dashboardPanel.classList.remove('is-visible');
    els.loginPanel.hidden = false;
    reveal(els.loginPanel);
    if (els.memePanel) {
      els.memePanel.hidden = true;
      els.memePanel.classList.remove('is-visible');
    }
    if (message) {
      els.loginMessage.hidden = false;
      els.loginMessage.textContent = message;
    } else {
      els.loginMessage.hidden = true;
      els.loginMessage.textContent = '';
    }
  };

  const showDashboard = () => {
    els.loginPanel.hidden = true;
    els.loginPanel.classList.remove('is-visible');
    els.dashboardPanel.hidden = false;
    els.loginMessage.hidden = true;
    reveal(els.dashboardPanel);
    if (els.memePanel && !els.memePanel.hidden) {
      reveal(els.memePanel);
    }
  };

  const fetchJSON = async (url, options = {}) => {
    const { skipAuth, ...rest } = options;
    const config = { ...rest };
    config.headers = new Headers(config.headers || {});
    if (config.body && !config.headers.has('Content-Type')) {
      config.headers.set('Content-Type', 'application/json');
    }
    if (!skipAuth && state.token) {
      config.headers.set('Authorization', `Bearer ${state.token}`);
    }
    const response = await fetch(url, config);
    const payload = await response.json().catch(() => ({}));
    if (!response.ok || payload.ok === false) {
      const error = new Error(payload.error || 'request_failed');
      error.response = response;
      error.payload = payload;
      throw error;
    }
    return payload;
  };

  const renderMember = () => {
    if (!state.member) return;
    els.memberName.textContent =
      state.member.displayName || state.member.loginId || state.member.id;
    const deptName = state.department?.name || 'General';
    els.memberMeta.textContent = `${deptName} • ${state.member.role ? state.member.role.toUpperCase() : 'MEMBER'}`;
  };

  const renderStats = () => {
    els.statsRow.innerHTML = '';
    const stats = state.stats || {};
    const statEntries = [
      { label: 'My open tasks', value: stats.myOpenTasks || 0 },
      { label: 'Blocked', value: stats.myBlockedTasks || 0 },
      { label: 'Upcoming events', value: stats.upcomingEvents || 0 }
    ];
    statEntries.forEach((stat) => {
      const pill = document.createElement('div');
      pill.className = 'stat-pill';
      pill.innerHTML = `<strong>${stat.value}</strong><span>${stat.label}</span>`;
      els.statsRow.appendChild(pill);
    });
  };

  const updateDepartmentFilter = () => {
    if (!els.departmentFilter) return;
    const options = [];
    const myTeamLabel = state.department?.name
      ? `My team (${state.department.name})`
      : 'My team';
    options.push({ value: 'mine', label: myTeamLabel });
    options.push({ value: 'all', label: 'All teams' });
    (state.departments || []).forEach((dept) => {
      if (!dept?.id) return;
      options.push({ value: dept.id, label: dept.name || dept.id });
    });

    const previous = state.filters.department;
    els.departmentFilter.innerHTML = '';
    options.forEach((opt) => {
      const optionEl = document.createElement('option');
      optionEl.value = opt.value;
      optionEl.textContent = opt.label;
      els.departmentFilter.appendChild(optionEl);
    });
    const allowed = options.map((opt) => opt.value);
    const nextValue = allowed.includes(previous) ? previous : 'mine';
    els.departmentFilter.value = nextValue;
    state.filters.department = nextValue;
  };

  const statusBadge = (status) => {
    const value = (status || 'todo').toLowerCase();
    const label = escapeHTML(value.replace('_', ' '));
    return `<span class="badge status-${value}">${label}</span>`;
  };

  const formatDateTime = (value) => {
    if (!value) return 'No due date';
    const date = new Date(value);
    if (Number.isNaN(date.getTime())) return 'No due date';
    return date.toLocaleString();
  };

  const renderTasks = () => {
    closeStatusMenu();
    els.taskList.innerHTML = '';
    if (!state.tasks.length) {
      const empty = document.createElement('p');
      empty.className = 'muted';
      empty.textContent = 'No tasks match the current filters.';
      els.taskList.appendChild(empty);
      return;
    }
    const memberRole = getMemberRole();
    const isElevated = memberRole === 'lead' || memberRole === 'mentor';
    state.tasks.forEach((task) => {
      const card = document.createElement('article');
      card.className = 'task-card';
      if (task.isMine) card.classList.add('task-card--mine');
      if (!task.hasOwners) card.classList.add('task-card--unassigned');
      if (task.departmentColor) {
        card.style.setProperty('--task-accent', task.departmentColor);
      }
      const title = escapeHTML(task.title || 'Untitled task');
      const description = escapeHTML(task.description || 'No description provided.');
      const departmentName = escapeHTML(task.departmentName || task.departmentId || 'N/A');
      const dueText = escapeHTML(formatDateTime(task.dueAt));
      const priorityRaw = (task.priority || 'medium').replace(/_/g, ' ');
      const priorityLabel = escapeHTML(
        priorityRaw ? priorityRaw.charAt(0).toUpperCase() + priorityRaw.slice(1) : 'Medium'
      );
      const updatesCount = typeof task.updatesCount === 'number' ? task.updatesCount : 0;
      const restrictionBadge = task.isRestricted
        ? '<span class="badge badge--warn">Lead &amp; mentor</span>'
        : '';
      const badges = [statusBadge(task.status)];
      if (restrictionBadge) {
        badges.push(restrictionBadge);
      }
      const owners = (task.owners || []).map((owner) => {
        indexPerson(owner);
        const label = escapeHTML(owner.displayName || owner.loginId || owner.id || 'Unknown');
        return `<span class="owner-chip">${label}</span>`;
      });
      const ownersBlock = owners.length ? owners.join('') : '<span class="badge badge--warn">Unassigned</span>';
      const metaItems = [
        `<span><strong>Due:</strong> ${dueText}</span>`,
        `<span><strong>Priority:</strong> ${priorityLabel}</span>`,
        `<span><strong>Updates:</strong> ${escapeHTML(String(updatesCount))}</span>`
      ];
      if (task.isRestricted) {
        metaItems.push('<span><strong>Visibility:</strong> Lead &amp; mentor</span>');
      }
      const actions = [];
      actions.push(`<button class="btn-ghost" data-action="update" data-task="${task.id}">Add update</button>`);
      if (task.lastUpdate?.member) {
        indexPerson(task.lastUpdate.member);
      }
      if (isElevated) {
        actions.push(`<button class="btn-ghost" data-action="edit" data-task="${task.id}">Update status</button>`);
      }
      const canEditTask = typeof task.canEdit === 'boolean' ? task.canEdit : isElevated;
      if (canEditTask) {
        actions.push(`<button class="btn-ghost" data-action="edit-task" data-task="${task.id}">Edit task</button>`);
      }
      const canUpdateDeadline =
        typeof task.canUpdateDeadline === 'boolean' ? task.canUpdateDeadline : isElevated;
      if (canUpdateDeadline) {
        actions.push(
          `<button class="btn-ghost" data-action="update-deadline" data-task="${task.id}">Update deadline</button>`
        );
      }
      const canDeleteTask = typeof task.canDelete === 'boolean' ? task.canDelete : isElevated;
      if (canDeleteTask) {
        actions.push(`<button class="btn-ghost" data-action="delete-task" data-task="${task.id}">Delete task</button>`);
      }
      if (task.canClaim) {
        actions.push(`<button class="btn-ghost" data-action="claim" data-task="${task.id}">Assign to me</button>`);
      }
      if (task.canUnclaim && task.isMine) {
        actions.push(`<button class="btn-ghost" data-action="unclaim" data-task="${task.id}">Release task</button>`);
      }
      const assignmentHint =
        !task.hasOwners && task.canClaim
          ? '<p class="assignment-hint">Nobody has picked this yet—claim it to avoid overlaps.</p>'
          : '';
      const lastUpdateBlock = task.lastUpdate
        ? `<div class="task-last-update"><strong>Last update:</strong> ${escapeHTML(task.lastUpdate.note || '')} — ${escapeHTML(task.lastUpdate.member?.displayName || task.lastUpdate.member?.loginId || task.lastUpdate.memberId || '')} (${escapeHTML(formatDateTime(task.lastUpdate.createdAt))})</div>`
        : '';
      card.innerHTML = `
        <h3>
          <span>${title}</span>
          <span class="task-badges">${badges.join(' ')}</span>
        </h3>
        <div class="task-team-tag">Team: ${departmentName}</div>
        <p>${description}</p>
        <div class="task-meta">
          ${metaItems.join('')}
        </div>
        <div class="task-owners">
          ${ownersBlock}
        </div>
        ${lastUpdateBlock}
        ${assignmentHint}
        <div class="task-actions">
          ${actions.join('')}
        </div>
        <details class="task-updates" data-task="${task.id}">
          <summary>View updates</summary>
          <div class="updates-list" data-updates="${task.id}">Loading updates...</div>
        </details>
      `;
      const updatesDetails = card.querySelector(`details.task-updates[data-task="${task.id}"]`);
      if (updatesDetails) {
        updatesDetails.dataset.updatesLoaded = 'false';
        updatesDetails.dataset.updatesLoading = 'false';
        updatesDetails.addEventListener('toggle', () => loadUpdatesIfNeeded(updatesDetails));
        const summaryEl = updatesDetails.querySelector('summary');
        if (summaryEl) {
          summaryEl.addEventListener('click', () =>
            requestAnimationFrame(() => loadUpdatesIfNeeded(updatesDetails))
          );
        }
      }
      els.taskList.appendChild(card);
      requestAnimationFrame(() => card.classList.add('task-card--show'));
    });
  };

  const renderEvents = () => {
    els.eventList.innerHTML = '';
    if (!state.events.length) {
      const empty = document.createElement('p');
      empty.className = 'muted';
      empty.textContent = 'No upcoming events.';
      els.eventList.appendChild(empty);
      return;
    }
    state.events.forEach((event) => {
      const card = document.createElement('article');
      card.className = 'event-card';
      const startDate = event.startAt ? new Date(event.startAt).toLocaleString() : 'TBD';
      const endDate = event.endAt ? new Date(event.endAt).toLocaleString() : '';
      const hostChips = (event.hostMembers || []).map((member) => {
        indexPerson(member);
        const label = escapeHTML(member.displayName || member.loginId || member.id || '');
        return `<span class="owner-chip">${label}</span>`;
      }).join('');
      card.innerHTML = `
        <h4>${escapeHTML(event.title || '')}</h4>
        <p>${escapeHTML(event.description || '')}</p>
        <p><strong>${startDate}</strong>${endDate ? ` → ${endDate}` : ''}</p>
        <p>${escapeHTML(event.location || '')}</p>
        ${hostChips ? `<div class="task-owners">${hostChips}</div>` : ''}
        ${event.link ? `<p><a href="${escapeHTML(event.link)}" target="_blank" rel="noopener noreferrer">Join/Details</a></p>` : ''}
      `;
      els.eventList.appendChild(card);
      requestAnimationFrame(() => card.classList.add('event-card--show'));
    });
  };

  const refreshTasks = async () => {
    const params = new URLSearchParams();
    if (state.filters.showMine) params.set('mine', 'true');
    if (state.filters.status && state.filters.status !== 'all') {
      params.set('status', state.filters.status);
    }
    if (state.filters.department && state.filters.department !== 'all') {
      const deptValue =
        state.filters.department === 'mine'
          ? state.department?.id || state.member?.departmentId
          : state.filters.department;
      if (deptValue) {
        params.set('department', deptValue);
      }
    }
    const query = params.toString();
    const response = await fetchJSON(`/api/team/tasks${query ? `?${query}` : ''}`);
    state.tasks = response.tasks || [];
    state.tasks.forEach((task) => {
      (task.owners || []).forEach(indexPerson);
    });
    renderTasks();
  };

  const refreshEvents = async () => {
    const response = await fetchJSON('/api/team/events');
    let events = Array.isArray(response.events) ? [...response.events] : [];
    const hasLiveHackathon = events.some(
      (event) =>
        typeof event.title === 'string' &&
        event.title.toLowerCase().includes('bugbash hackathon 22nd november')
    );
    if (!hasLiveHackathon) {
      events.unshift({
        id: 'event-bugbash-hackathon-live',
        title: 'BugBash Hackathon – 22 November',
        description: 'Final production push: doors open at 8:00 am, finale showcase 7:00 pm.',
        startAt: '2025-11-22T08:00:00.000Z',
        endAt: '2025-11-22T19:00:00.000Z',
        location: 'SVYASA Main Hall & Labs',
        link: '',
        hosts: [],
        hostMembers: [],
        departmentIds: []
      });
    }
    state.events = events;
    renderEvents();
    if (state.stats) {
      state.stats.upcomingEvents = events.length;
      renderStats();
    }
  };

  const refreshProfile = async () => {
    const response = await fetchJSON('/api/team/me');
    state.member = response.member;
    state.department = response.department;
    state.departments = response.departments || [];
    state.stats = response.stats || {};
    indexPerson(state.member);
    renderMember();
    renderStats();
    renderMeme();
    updateDepartmentFilter();
    els.myTasksToggle.checked = state.filters.showMine;
    const memberRole = getMemberRole();
    if (['lead', 'mentor', 'member'].includes(memberRole)) {
      els.newTaskBtn.hidden = false;
    } else {
      els.newTaskBtn.hidden = true;
    }
  };

  const loadInitialData = async () => {
    try {
      setStatus('Loading dashboard...');
      await refreshProfile();
      await Promise.all([refreshTasks(), refreshEvents()]);
      setStatus('');
      showDashboard();
    } catch (err) {
      console.error(err);
      const errorCode = err?.payload?.error || '';
      if (errorCode === 'invalid_session' || errorCode === 'unauthorized') {
        setToken(null);
        showLogin('Session expired. Please sign in again.');
        return;
      }
      setStatus('Could not load dashboard. Please try again.', 'error');
    }
  };

  const handleLogin = async (event) => {
    event.preventDefault();
    const formData = new FormData(els.loginForm);
    const identifierRaw = (formData.get('identifier') || '').toString();
    const codeRaw = (formData.get('code') || '').toString();
    const identifier = identifierRaw.trim().replace(/\s+/g, ' ');
    const code = codeRaw.trim();
    if (!identifier || !code) {
      els.loginMessage.hidden = false;
      els.loginMessage.textContent = 'Enter both your name and password.';
      return;
    }
    if (!/^[A-Za-z\s]+$/.test(identifier)) {
      els.loginMessage.hidden = false;
      els.loginMessage.textContent = 'Use letters and spaces only for your name.';
      return;
    }
    els.loginSubmit.disabled = true;
    els.loginSubmit.textContent = 'Signing in...';
    els.loginMessage.hidden = true;
    try {
      const payload = await fetchJSON('/api/team/login', {
        method: 'POST',
        body: JSON.stringify({ email: identifier, code }),
        skipAuth: true
      });
      setToken(payload.token);
      state.member = payload.member;
      state.department = payload.department;
      state.stats = payload.stats || {};
      els.loginForm.reset();
      loadInitialData();
    } catch (err) {
      const errorCode = err.payload?.error || 'signin_failed';
      const messages = {
        missing_credentials: 'Enter both your name and password.',
        member_not_found: 'We could not find that name. Check the spelling.',
        invalid_credentials: 'Password did not match. Check the latest password.',
        access_not_configured: 'Access for this name is not configured yet.',
        team_dashboard_disabled: 'Team dashboard is disabled right now.',
        signin_failed: 'Sign-in failed. Try again.'
      };
      els.loginMessage.hidden = false;
      els.loginMessage.textContent = messages[errorCode] || 'Could not sign in. Try again.';
    } finally {
      els.loginSubmit.disabled = false;
      els.loginSubmit.textContent = 'Sign in';
    }
  };

  const handleLogout = async () => {
    try {
      await fetchJSON('/api/team/logout', { method: 'POST' });
    } catch (err) {
      console.warn('Logout request failed', err);
    } finally {
      setToken(null);
      state.member = null;
      showLogin('Signed out.');
    }
  };

  const loadUpdatesIfNeeded = async (detailsEl) => {
    if (!detailsEl.open) return;
    if (detailsEl.dataset.updatesLoaded === 'true') return;
    if (detailsEl.dataset.updatesLoading === 'true') return;
    detailsEl.dataset.updatesLoading = 'true';
    const taskId = detailsEl.dataset.task;
    if (!taskId) return;
    const container = detailsEl.querySelector(`[data-updates="${taskId}"]`);
    if (!container) return;
    try {
      container.textContent = 'Loading updates...';
      const response = await fetchJSON(`/api/team/tasks/${encodeURIComponent(taskId)}/updates`);
      const updates = Array.isArray(response.updates) ? [...response.updates] : [];
      const fallbackTask = state.tasks.find((task) => task.id === taskId);
      if (fallbackTask?.lastUpdate) {
        const exists = updates.some((item) => item?.id === fallbackTask.lastUpdate.id);
        if (!exists) {
          updates.unshift({
            id: fallbackTask.lastUpdate.id || 'last-update',
            note: fallbackTask.lastUpdate.note || '',
            statusAfter: fallbackTask.lastUpdate.statusAfter || fallbackTask.lastUpdate.status || '',
            createdAt: fallbackTask.lastUpdate.createdAt || '',
            member: fallbackTask.lastUpdate.member,
            memberId: fallbackTask.lastUpdate.memberId
          });
        }
      }
      if (!updates.length) {
        container.textContent = 'No updates yet.';
        detailsEl.dataset.updatesLoaded = 'true';
        return;
      }
      const markup = updates
        .map((update) => {
          indexPerson(update.member);
          const memberName =
            update.member?.displayName || update.member?.loginId || update.member?.id || 'Unknown';
          const statusText = update.statusAfter
            ? ` • ${escapeHTML(update.statusAfter.replace('_',' '))}`
            : '';
          const timestamp = update.createdAt ? formatDateTime(update.createdAt) : '';
          return `<div class="update-pill"><strong>${escapeHTML(memberName)}${statusText}</strong><span>${escapeHTML(update.note || '')}</span><br/><small>${escapeHTML(timestamp)}</small></div>`;
        })
        .join('');
      container.innerHTML = markup;
      detailsEl.dataset.updatesLoaded = 'true';
    } catch (err) {
      const errorCode = err.payload?.error || '';
      if (errorCode === 'forbidden') {
        container.textContent = 'You do not have permission to view updates on this task.';
      } else {
        container.textContent = 'Could not load updates.';
      }
    } finally {
      detailsEl.dataset.updatesLoading = 'false';
    }
  };

  const handleTaskAction = async (event) => {
    const button = event.target.closest('button[data-action]');
    if (!button) return;
    const action = button.dataset.action;
    const taskId = button.dataset.task;
    if (!taskId) return;
    const task = state.tasks.find((item) => item.id === taskId) || null;
    const elevated = isElevatedMember();
    closeStatusMenu();
    if (action === 'update') {
      const noteInput = prompt('Add a short progress update (120 chars max).', '');
      if (noteInput === null) return;
      const trimmedNote = noteInput.trim();
      if (!trimmedNote) {
        setStatus('Write a note before submitting an update.', 'error');
        return;
      }
      if (trimmedNote.length > 240) {
        alert('Please keep the update concise (under 240 characters).');
        return;
      }
      try {
        await fetchJSON(`/api/team/tasks/${encodeURIComponent(taskId)}/updates`, {
          method: 'POST',
          body: JSON.stringify({ note: trimmedNote })
        });
        setStatus('Update saved.', 'success');
        await refreshProfile();
        await refreshTasks();
      } catch (err) {
        const errorCode = err.payload?.error || 'update_failed';
        const messages = {
          missing_note: 'Write a note before submitting an update.',
          invalid_status: 'Status update not recognised.',
          forbidden: 'You do not have permission to update this task.',
          update_failed: 'Could not save update. Try again.'
        };
        setStatus(messages[errorCode] || 'Could not save update.', 'error');
      }
      return;
    }
    if (action === 'edit') {
      if (!elevated) {
        setStatus('Only leads and mentors can update status.', 'error');
        return;
      }
      if (!task) {
        setStatus('Could not load task details.', 'error');
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      openStatusMenu(button, task);
      return;
    }
    if (action === 'edit-task') {
      if (!elevated) {
        setStatus('Only leads and mentors can edit task details.', 'error');
        return;
      }
      const updatedTitle = prompt('Update task title:', task?.title || '');
      if (updatedTitle === null) return;
      const trimmedTitle = updatedTitle.trim();
      if (!trimmedTitle) {
        alert('Task title cannot be empty.');
        return;
      }
      const updatedDescription = prompt(
        'Update task description (leave blank to clear):',
        task?.description || ''
      );
      if (updatedDescription === null) return;
      const updatedPriority = prompt(
        'Update priority (low, medium, high):',
        (task?.priority || 'medium').toLowerCase()
      );
      if (updatedPriority === null) return;
      const normalizedPriority = updatedPriority.trim().toLowerCase();
      if (normalizedPriority && !['low', 'medium', 'high'].includes(normalizedPriority)) {
        alert('Priority must be low, medium, or high.');
        return;
      }
      const payload = {};
      if (trimmedTitle !== (task?.title || '')) {
        payload.title = trimmedTitle;
      }
      const trimmedDescription = (updatedDescription || '').trim();
      if (trimmedDescription !== (task?.description || '').trim()) {
        payload.description = trimmedDescription;
      }
      if (
        normalizedPriority &&
        normalizedPriority !== (task?.priority || '').toLowerCase()
      ) {
        payload.priority = normalizedPriority;
      }
      if (!Object.keys(payload).length) {
        setStatus('No changes to save.');
        return;
      }
      try {
        await fetchJSON(`/api/team/tasks/${encodeURIComponent(taskId)}`, {
          method: 'PATCH',
          body: JSON.stringify(payload)
        });
        setStatus('Task details updated.', 'success');
        await refreshProfile();
        await refreshTasks();
      } catch (err) {
        const errorCode = err.payload?.error || 'update_failed';
        const messages = {
          missing_title: 'Task title cannot be empty.',
          forbidden: 'You do not have permission to edit this task.',
          server_error: 'Server error while updating.',
          update_failed: 'Could not update task.'
        };
        setStatus(messages[errorCode] || 'Could not update task.', 'error');
      }
      return;
    }
    if (action === 'update-deadline') {
      if (!elevated) {
        setStatus('Only leads and mentors can update deadlines.', 'error');
        return;
      }
      const defaultDue =
        task?.dueAt && !Number.isNaN(new Date(task.dueAt).getTime())
          ? new Date(task.dueAt).toISOString()
          : '';
      const input = prompt(
        'Enter new due date/time (ISO 8601 or YYYY-MM-DD). Leave empty to clear:',
        defaultDue
      );
      if (input === null) return;
      const value = input.trim();
      const payload = { dueAt: value };
      if (!value) {
        payload.dueAt = '';
      }
      try {
        await fetchJSON(`/api/team/tasks/${encodeURIComponent(taskId)}`, {
          method: 'PATCH',
          body: JSON.stringify(payload)
        });
        setStatus('Deadline updated.', 'success');
        await refreshProfile();
        await refreshTasks();
      } catch (err) {
        const errorCode = err.payload?.error || 'update_failed';
        const messages = {
          invalid_status: 'Due date was not accepted.',
          forbidden: 'You do not have permission to change the deadline.',
          update_failed: 'Could not update deadline.'
        };
        setStatus(messages[errorCode] || 'Could not update deadline.', 'error');
      }
      return;
    }
    if (action === 'delete-task') {
      if (!elevated) {
        setStatus('Only leads and mentors can delete tasks.', 'error');
        return;
      }
      if (!confirm('Delete this task? This action cannot be undone.')) return;
      try {
        await fetchJSON(`/api/team/tasks/${encodeURIComponent(taskId)}`, {
          method: 'DELETE'
        });
        setStatus('Task deleted.', 'success');
        await refreshProfile();
        await refreshTasks();
      } catch (err) {
        const errorCode = err.payload?.error || 'delete_failed';
        const messages = {
          forbidden: 'You do not have permission to delete this task.',
          task_not_found: 'Task was already deleted.',
          delete_failed: 'Could not delete task.'
        };
        setStatus(messages[errorCode] || 'Could not delete task.', 'error');
      }
      return;
    }
    if (action === 'claim' || action === 'unclaim') {
      try {
        await fetchJSON(`/api/team/tasks/${encodeURIComponent(taskId)}/claim`, {
          method: 'POST',
          body: JSON.stringify({ action: action === 'claim' ? 'claim' : 'unclaim' })
        });
        setStatus(
          action === 'claim' ? 'Task assigned to you.' : 'Task released.',
          'success'
        );
        await refreshProfile();
        await refreshTasks();
      } catch (err) {
        const errorCode = err.payload?.error || 'claim_failed';
        const messages = {
          already_claimed: 'Someone already picked this task. Sync with them before joining.',
          not_assigned: 'You are not on this task.',
          forbidden: 'You cannot change assignment on this task.',
          claim_failed: 'Could not update assignment. Try again.'
        };
        setStatus(messages[errorCode] || 'Could not update assignment.', 'error');
      }
    }
  };

  const handleCreateTask = async () => {
    const titleInput = prompt('Task title:', '');
    if (titleInput === null) return;
    const trimmedTitle = titleInput.trim();
    if (!trimmedTitle) {
      alert('Task title cannot be empty.');
      return;
    }
    const descriptionInput = prompt('Describe the task (optional):', '');
    if (descriptionInput === null) return;
    const description = descriptionInput.trim();
    const dueAtInput = prompt('Due date (YYYY-MM-DD or leave blank):', '');
    if (dueAtInput === null) return;
    const payload = { title: trimmedTitle, description };
    const role = getMemberRole();
    const elevated = role === 'lead' || role === 'mentor';
    const dueAt = dueAtInput.trim();
    if (dueAt) {
      payload.dueAt = dueAt.endsWith('Z') || dueAt.includes('T') ? dueAt : `${dueAt}T09:00:00.000Z`;
    }
    try {
      await fetchJSON('/api/team/tasks', {
        method: 'POST',
        body: JSON.stringify(payload)
      });
      const successMessage = elevated
        ? 'Task created.'
        : 'Task submitted to leads & mentors.';
      setStatus(successMessage, 'success');
      await refreshProfile();
      await refreshTasks();
    } catch (err) {
      const errorCode = err.payload?.error || 'create_failed';
      const messages = {
        missing_title: 'Give the task a title.',
        invalid_owner: 'One of the selected owners is invalid.',
        invalid_department: 'Select a valid department before creating tasks.',
        forbidden: 'You do not have permission to create tasks.',
        create_failed: 'Could not create the task.'
      };
      setStatus(messages[errorCode] || 'Could not create the task.', 'error');
    }
  };

  els.loginForm.addEventListener('submit', handleLogin);
  els.logoutBtn.addEventListener('click', handleLogout);
  els.refreshBtn.addEventListener('click', async () => {
    setStatus('Refreshing...');
    await refreshProfile();
    await Promise.all([refreshTasks(), refreshEvents()]);
    setStatus('Refreshed.', 'success');
    setTimeout(clearStatus, 2000);
  });
  if (els.memeShuffle) {
    els.memeShuffle.addEventListener('click', () => {
      renderMeme();
      setStatus('Here’s a fresh meme for the sprint!', 'success');
      setTimeout(clearStatus, 2000);
    });
  }
  els.taskList.addEventListener('click', handleTaskAction);
  els.taskList.addEventListener('toggle', (event) => {
    if (event.target.matches('details.task-updates')) {
      loadUpdatesIfNeeded(event.target);
    }
  });
  els.departmentFilter.addEventListener('change', async (event) => {
    state.filters.department = event.target.value;
    await refreshTasks();
  });
  els.myTasksToggle.addEventListener('change', async (event) => {
    state.filters.showMine = event.target.checked;
    await refreshTasks();
  });
  els.statusFilter.addEventListener('change', async (event) => {
    state.filters.status = event.target.value;
    await refreshTasks();
  });
  els.newTaskBtn.addEventListener('click', handleCreateTask);

  showLogin();
})();
</script>
</body>
</html>
