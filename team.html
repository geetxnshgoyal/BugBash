<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Team Dashboard • Bug Bash</title>
<link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"/>
<meta name="robots" content="noindex,nofollow"/>
<style>
  :root{
    --bg1:#0f1720;--bg2:#0b1020;
    --glass:rgba(255,255,255,0.06);--glass2:rgba(255,255,255,0.03);
    --accent:#7be04a;--accent-soft:rgba(123,224,74,0.18);
    --muted:#94a3b8;--danger:#f87171;--warning:#facc15;
    --white:#f8fafc;--shadow:0 18px 44px rgba(2,8,23,0.6);
    --font:'Segoe UI',Roboto,Helvetica,system-ui,sans-serif;
    --badge-bg:rgba(148,163,184,0.16);--badge-color:#e2e8f0;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    min-height:100vh;
    font-family:var(--font);
    color:var(--white);
    background:
      radial-gradient(1200px 600px at 10% 10%,rgba(123,224,74,0.05),transparent),
      linear-gradient(180deg,var(--bg1),var(--bg2));
    position:relative;
    overflow-x:hidden;
  }
  #bg-canvas{
    position:fixed;
    inset:0;
    z-index:0;
    pointer-events:none;
    opacity:.65;
    mix-blend-mode:screen;
  }
  a{color:var(--accent)}
  .wrap{
    max-width:1200px;
    margin:0 auto;
    padding:32px 20px 80px;
    position:relative;
    z-index:2;
  }
  header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:18px;
    margin-bottom:28px;
  }
  .brand{font-size:22px;font-weight:800;letter-spacing:.6px;color:var(--white);text-decoration:none;display:inline-flex;align-items:center;gap:6px}
  .brand span{color:var(--accent)}
  .nav-actions{
    display:flex;
    gap:12px;
    align-items:center;
  }
  .nav-actions a{
    color:var(--muted);
    text-decoration:none;
    font-size:14px;
  }
  .panel{
    background:linear-gradient(180deg,var(--glass),transparent);
    border-radius:18px;
    padding:28px;
    box-shadow:var(--shadow);
    backdrop-filter:blur(6px);
    opacity:0;
    transform:translateY(18px);
    transition:opacity .5s ease,transform .5s ease;
  }
  .panel.is-visible{
    opacity:1;
    transform:translateY(0);
  }
  .dashboard[hidden], .meme-panel[hidden]{display:none !important;}
  h1{margin:0 0 16px;font-size:28px}
  h2{margin:0;font-size:22px}
  .muted{color:var(--muted);margin:0 0 18px;font-size:15px}
  label{display:flex;flex-direction:column;gap:6px;margin-bottom:16px;font-size:14px;color:var(--muted)}
  input,select,textarea{
    padding:12px 14px;
    border-radius:10px;
    border:1px solid rgba(148,163,184,0.28);
    background:var(--glass2);
    color:var(--white);
    font:inherit;
  }
  input[type=date]{
    color-scheme:dark;
  }
  input[type=date]::-webkit-calendar-picker-indicator{
    filter:invert(1);
    cursor:pointer;
  }
  input[type=date]::-webkit-calendar-picker-indicator:hover{
    filter:invert(1) brightness(1.2);
  }
  input:focus,select:focus,textarea:focus{
    outline:2px solid var(--accent);
    outline-offset:2px;
  }
  button{
    border:none;
    border-radius:999px;
    padding:12px 20px;
    font:inherit;
    font-weight:600;
    cursor:pointer;
    background:var(--accent);
    color:#041007;
    transition:transform .15s ease,box-shadow .15s ease;
  }
  button:hover{transform:translateY(-1px);box-shadow:0 8px 20px rgba(123,224,74,0.35)}
  button:disabled{opacity:.6;cursor:not-allowed;box-shadow:none;transform:none}
  .btn-ghost{
    background:transparent;
    color:var(--muted);
    border:1px solid rgba(148,163,184,0.3);
    padding:10px 18px;
  }
  .layout{
    display:grid;
    gap:24px;
  }
  .dashboard{
    display:grid;
    gap:24px;
  }
  .dashboard-header{
    display:flex;
    flex-wrap:wrap;
    gap:20px;
    align-items:center;
    justify-content:space-between;
  }
  .meme-panel{
    margin:10px 0 24px;
    padding:18px 22px;
    border-radius:16px;
    background:rgba(15,23,42,0.6);
    border:1px solid rgba(148,163,184,0.22);
    display:flex;
    flex-direction:column;
    gap:12px;
    opacity:0;
    transform:translateY(12px);
    transition:opacity .28s ease,transform .28s ease;
  }
  .meme-panel.is-visible{opacity:1;transform:translateY(0);}
  .meme-panel h3{
    margin:0;
    font-size:16px;
    letter-spacing:.3px;
    color:var(--accent);
  }
  .meme-panel p{
    margin:0;
    color:#cbd5f5;
    font-size:14px;
    line-height:1.5;
  }
  .meme-panel .meme-footer{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:10px;
    font-size:12px;
    color:var(--muted);
  }
  .member-card{
    padding:18px 22px;
    border-radius:16px;
    background:var(--glass2);
    border:1px solid rgba(148,163,184,0.18);
    min-width:260px;
  }
  .member-card h3{margin:0 0 6px;font-size:18px}
  .member-meta{margin:0;font-size:14px;color:var(--muted)}
  .stats{
    display:flex;
    gap:14px;
    flex-wrap:wrap;
  }
  .stat-pill{
    background:var(--glass2);
    border-radius:14px;
    padding:14px 18px;
    border:1px solid rgba(148,163,184,0.18);
    min-width:140px;
  }
  .stat-pill strong{display:block;font-size:20px;color:var(--accent)}
  .task-section,.event-section{
    background:var(--glass2);
    border-radius:18px;
    border:1px solid rgba(148,163,184,0.18);
    padding:24px;
  }
  .section-header{
    display:flex;
    flex-wrap:wrap;
    gap:14px;
    justify-content:space-between;
    align-items:center;
    margin-bottom:18px;
  }
  .filters{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    align-items:center;
  }
  .filters label.inline{
    display:inline-flex;
    align-items:center;
    gap:6px;
    margin:0;
    color:var(--muted);
    font-size:13px;
  }
  .badge{
    display:inline-flex;
    align-items:center;
    gap:6px;
    background:var(--badge-bg);
    color:var(--badge-color);
    padding:4px 10px;
    border-radius:999px;
    font-size:12px;
    text-transform:uppercase;
    letter-spacing:.6px;
  }
  .badge.status-todo{background:rgba(148,163,184,0.18);color:#f1f5f9}
  .badge.status-in_progress{background:rgba(59,130,246,0.18);color:#60a5fa}
  .badge.status-blocked{background:rgba(248,113,113,0.18);color:#fca5a5}
  .badge.status-done{background:rgba(94,234,212,0.18);color:#5eead4}
  .task-list{
    display:grid;
    gap:16px;
  }
  .task-card{
    position:relative;
    border-radius:16px;
    border:1px solid rgba(148,163,184,0.18);
    background:linear-gradient(180deg,var(--glass),transparent);
    padding:20px;
    --task-accent: var(--accent);
    border-left:6px solid var(--task-accent);
    transition:box-shadow .18s ease,transform .18s ease,opacity .28s ease;
    opacity:0;
    transform:translateY(18px);
  }
  .task-card--show{opacity:1;transform:translateY(0);}
  .task-card::after{
    content:'';
    position:absolute;
    inset:0;
    border-radius:16px;
    pointer-events:none;
    border:1px solid rgba(123,224,74,0);
    transition:border .18s ease;
  }
  .task-card--mine{
    box-shadow:0 0 0 1px var(--task-accent),0 18px 30px rgba(123,224,74,0.18);
    transform:translateY(-1px);
  }
  .task-card--mine::after{
    border-color:rgba(123,224,74,0.25);
  }
  .task-card--unassigned{
    border-style:dashed;
  }
  .task-card h3{
    margin:0 0 10px;
    font-size:18px;
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:10px;
  }
  .task-badges{
    display:flex;
    gap:6px;
    flex-wrap:wrap;
    justify-content:flex-end;
  }
  .task-card p{margin:6px 0 12px;font-size:14px;color:var(--muted)}
  .task-team-tag{
    display:inline-flex;
    align-items:center;
    gap:6px;
    font-size:12px;
    padding:4px 10px;
    border-radius:999px;
    border:1px solid currentColor;
    color:var(--task-accent);
    background:rgba(255,255,255,0.04);
    margin-bottom:10px;
    text-transform:uppercase;
    letter-spacing:.5px;
  }
  .task-meta{
    display:flex;
    flex-wrap:wrap;
    gap:12px;
    font-size:13px;
    color:var(--muted);
  }
  .task-meta span strong{color:var(--white)}
  .task-actions{
    display:flex;
    gap:12px;
    flex-wrap:wrap;
    margin-top:14px;
  }
  .task-actions button{
    padding:8px 16px;
    font-size:13px;
  }
  body.modal-open{
    overflow:hidden;
  }
  .modal-backdrop{
    position:fixed;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:28px 20px;
    background:rgba(2,10,20,0.78);
    backdrop-filter:blur(10px);
    z-index:60;
    opacity:0;
    pointer-events:none;
    transition:opacity .24s ease;
  }
  .modal-backdrop.is-open{
    opacity:1;
    pointer-events:all;
  }
  .modal-panel{
    width:100%;
    max-width:520px;
    background:linear-gradient(180deg,rgba(19,32,54,0.88),rgba(8,14,26,0.92));
    border-radius:20px;
    border:1px solid rgba(123,224,74,0.18);
    box-shadow:0 28px 64px rgba(4,12,24,0.55);
    padding:24px 26px;
    position:relative;
    transform:translateY(18px);
    transition:transform .24s ease;
  }
  .modal-backdrop.is-open .modal-panel{
    transform:translateY(0);
  }
  .modal-header{
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap:18px;
    margin-bottom:14px;
  }
  .modal-header h3{
    margin:0;
    font-size:20px;
    letter-spacing:.4px;
  }
  .modal-tagline{
    margin:0 0 18px;
    font-size:14px;
    color:var(--muted);
  }
  .modal-close{
    border:none;
    background:rgba(148,163,184,0.1);
    color:var(--muted);
    border-radius:999px;
    width:32px;
    height:32px;
    font-size:18px;
    line-height:1;
    cursor:pointer;
    display:flex;
    align-items:center;
    justify-content:center;
    transition:background .18s ease,color .18s ease;
  }
  .modal-close:hover{
    background:rgba(123,224,74,0.2);
    color:var(--accent);
  }
  .modal-body{
    display:grid;
    gap:16px;
  }
  .modal-body label{
    margin:0;
  }
  .modal-body input,
  .modal-body select,
  .modal-body textarea{
    width:100%;
  }
  .modal-body textarea{
    min-height:96px;
    resize:vertical;
  }
  .modal-body select[multiple]{
    min-height:160px;
    padding:10px 12px;
  }
  .modal-meta{
    font-size:13px;
    color:var(--muted);
  }
  .modal-actions{
    display:flex;
    justify-content:flex-end;
    gap:12px;
    margin-top:10px;
  }
  .modal-actions .btn-ghost{
    padding:10px 18px;
  }
  .modal-hint{
    display:block;
    margin-top:6px;
    font-size:12px;
    color:var(--muted);
  }
  .modal-status{
    margin:4px 0 0;
    font-size:13px;
    color:var(--muted);
  }
  .modal-status.error{color:var(--danger);}
  .modal-status.success{color:var(--accent);}
  .modal-divider{
    height:1px;
    background:rgba(148,163,184,0.18);
    margin:4px 0 4px;
    border:none;
  }
  .modal-highlight{
    display:inline-flex;
    align-items:center;
    gap:8px;
    font-size:13px;
    color:var(--muted);
    background:rgba(123,224,74,0.12);
    padding:8px 12px;
    border-radius:12px;
    border:1px solid rgba(123,224,74,0.18);
  }
  .status-menu{
    position:absolute;
    z-index:40;
    min-width:180px;
    background:rgba(15,23,42,0.95);
    border:1px solid rgba(123,224,74,0.18);
    border-radius:12px;
    padding:6px;
    display:flex;
    flex-direction:column;
    gap:4px;
    box-shadow:0 18px 40px rgba(2,8,23,0.5);
    backdrop-filter:blur(10px);
  }
  .status-menu__item{
    border:none;
    background:transparent;
    color:var(--white);
    text-align:left;
    padding:8px 12px;
    border-radius:8px;
    font:inherit;
    cursor:pointer;
    transition:background .18s ease,color .18s ease;
  }
  .status-menu__item:hover,
  .status-menu__item:focus{
    background:rgba(123,224,74,0.18);
    color:var(--accent);
    outline:none;
  }
  .status-menu__item.is-active{
    background:rgba(123,224,74,0.24);
    color:var(--accent);
    font-weight:600;
  }
  .task-owners{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
    margin-top:6px;
  }
  .owner-chip{
    background:rgba(148,163,184,0.16);
    border-radius:999px;
    padding:4px 10px;
    font-size:12px;
    color:#e2e8f0;
  }
  .badge.badge--warn{
    background:rgba(250,204,21,0.16);
    color:#fde68a;
  }
  .assignment-hint{
    margin:10px 0 0;
    font-size:13px;
    color:#e2e8f0;
  }
  .task-last-update{
    margin-top:12px;
    font-size:13px;
    color:var(--muted);
  }
  .task-last-update strong{
    color:var(--white);
  }
  .task-actions button{
    padding:8px 16px;
    font-size:13px;
  }
  details.task-updates{
    margin-top:14px;
    border-top:1px solid rgba(148,163,184,0.16);
    padding-top:12px;
  }
  details.task-updates summary{
    cursor:pointer;
    font-size:13px;
    color:var(--muted);
    display:flex;
    align-items:center;
    gap:6px;
    transition:color .2s ease;
  }
  details.task-updates summary::before{
    content:'▸';
    font-size:12px;
    transition:transform .2s ease;
  }
  details.task-updates[open] summary::before{transform:rotate(90deg);}
  details.task-updates[open] summary{color:var(--accent);}
  .updates-list{
    margin-top:10px;
    display:grid;
    gap:10px;
    opacity:0;
    transform:translateY(-6px);
    transition:opacity .25s ease,transform .25s ease;
  }
  details.task-updates[open] .updates-list{
    opacity:1;
    transform:translateY(0);
  }
  .update-pill{
    background:rgba(15,23,42,0.55);
    border-radius:12px;
    padding:10px 12px;
    border:1px solid rgba(148,163,184,0.14);
    font-size:13px;
  }
  .update-pill strong{display:block;color:var(--white);margin-bottom:4px}
  .events-list{
    display:grid;
    gap:14px;
  }
  .event-card{
    border-radius:14px;
    border:1px solid rgba(148,163,184,0.16);
    background:rgba(15,23,42,0.55);
    padding:16px 18px;
    opacity:0;
    transform:translateY(12px);
    transition:opacity .28s ease,transform .28s ease;
  }
  .event-card--show{opacity:1;transform:translateY(0);}
  .event-card h4{margin:0 0 6px;font-size:16px}
  .event-card p{margin:4px 0;font-size:13px;color:var(--muted)}
  .status-message{
    margin-top:12px;
    font-size:14px;
    color:var(--muted);
  }
  .status-message.error{color:var(--danger)}
  .status-message.success{color:var(--accent)}
  @media(max-width:960px){
    .dashboard{gap:18px}
    .task-section,.event-section{padding:20px}
  }
  @media(min-width:900px){
    .dashboard-main{
      display:grid;
      grid-template-columns:minmax(0,2fr) minmax(0,1fr);
      gap:20px;
      align-items:start;
    }
  }
  @media(prefers-reduced-motion:reduce){
    *,*::before,*::after{
      animation-duration:.01ms!important;
      animation-iteration-count:1!important;
      transition-duration:.01ms!important;
      scroll-behavior:auto!important;
    }
  }
</style>
</head>
<body>
<canvas id="bg-canvas"></canvas>
<div class="wrap">
  <header>
    <a class="brand" href="/">BUG BASH <span>Team</span></a>
    <div class="nav-actions">
      <a href="/register">Registration</a>
      <a href="/admin">Admin</a>
    </div>
  </header>

  <main class="layout">
    <section class="panel" id="loginPanel">
      <h1>Team Dashboard</h1>
      <p class="muted">Private workspace for NST organizers. Sign in with your name and the latest password.</p>
      <form id="loginForm" autocomplete="off">
        <label>Name
          <input type="text" name="identifier" required placeholder="Enter your name" autocomplete="off" pattern="[A-Za-z ]+" title="Use letters and spaces only">
        </label>
        <label>Password
          <input type="password" name="code" required placeholder="Password">
        </label>
        <button type="submit" id="loginSubmit">Sign in</button>
      </form>
      <p id="loginMessage" class="status-message" hidden></p>
    </section>

    <section class="dashboard" id="dashboardPanel" hidden>
      <div class="dashboard-header">
        <div class="member-card" id="memberCard">
          <h3 id="memberName"></h3>
          <p class="member-meta" id="memberMeta"></p>
        </div>
        <div class="stats" id="statsRow"></div>
        <div class="nav-actions">
          <button class="btn-ghost" id="announcementBtn" hidden>Announcement</button>
          <button class="btn-ghost" id="refreshBtn">Refresh</button>
          <button class="btn-ghost" id="logoutBtn">Sign out</button>
        </div>
      </div>

      <section class="meme-panel" id="memePanel" hidden>
        <h3>🎉 Meme of the Sprint</h3>
        <p id="memeText"></p>
        <div class="meme-footer">
          <span id="memeAttribution"></span>
          <button class="btn-ghost" id="memeShuffle" type="button">New meme</button>
        </div>
      </section>

      <p id="dashboardStatus" class="status-message" hidden></p>

      <div class="dashboard-main">
        <div class="task-section">
          <div class="section-header">
            <h2>Tasks</h2>
            <div class="filters">
              <select id="departmentFilter">
                <option value="mine">My team</option>
                <option value="all">All teams</option>
              </select>
              <select id="statusFilter">
                <option value="all">All statuses</option>
                <option value="todo">To do</option>
                <option value="in_progress">In progress</option>
                <option value="blocked">Blocked</option>
                <option value="done">Completed</option>
              </select>
              <label class="inline">
                <input type="checkbox" id="myTasksToggle">
                Assigned to me
              </label>
              <button id="newTaskBtn" hidden>Create task</button>
            </div>
          </div>
          <div class="task-list" id="taskList"></div>
        </div>

        <aside class="event-section">
          <div class="section-header">
            <h2>Upcoming</h2>
          </div>
          <div class="events-list" id="eventList"></div>
        </aside>
      </div>
    </section>
  </main>

  <div class="modal-backdrop" id="taskModal" hidden>
    <div class="modal-panel" role="dialog" aria-modal="true" aria-labelledby="taskModalTitleLabel">
      <div class="modal-header">
        <h3 id="taskModalTitleLabel">Create Task</h3>
        <button type="button" class="modal-close" data-close-modal="taskModal" aria-label="Close create task modal">×</button>
      </div>
      <p class="modal-tagline">Launch a fresh mission for the crew. Leads can route tasks across any team.</p>
      <form id="taskModalForm" class="modal-body">
        <label>
          Task title
          <input type="text" id="taskModalTitle" name="title" required maxlength="120" placeholder="e.g. Prep kickoff slides">
        </label>
        <label>
          Task details
          <textarea id="taskModalDescription" name="description" maxlength="500" placeholder="Outline key steps, context, or links."></textarea>
        </label>
        <label>
          Department
          <select id="taskModalDepartment" name="department" required>
            <option value="">Select a department...</option>
          </select>
        </label>
        <label>
          Due date
          <input type="date" id="taskModalDue" name="due">
        </label>
        <label id="taskModalOwnersWrapper" hidden>
          Assign to teammates
          <select id="taskModalOwners" name="ownerIds" multiple size="6"></select>
          <span class="modal-hint">Hold Cmd (⌘) or Ctrl to select multiple teammates.</span>
        </label>
        <p class="modal-status" id="taskModalStatus" hidden></p>
        <hr class="modal-divider">
        <div class="modal-actions">
          <button type="button" class="btn-ghost" id="taskModalCancel">Cancel</button>
          <button type="submit" id="taskModalSubmit">Create task</button>
        </div>
      </form>
    </div>
  </div>

  <div class="modal-backdrop" id="updateModal" hidden>
    <div class="modal-panel" role="dialog" aria-modal="true" aria-labelledby="updateModalTitle">
      <div class="modal-header">
        <h3 id="updateModalTitle">Add Progress Update</h3>
        <button type="button" class="modal-close" data-close-modal="updateModal" aria-label="Close update modal">×</button>
      </div>
      <div class="modal-highlight">
        <span id="updateModalTaskName"></span>
        <span id="updateModalTaskStatus"></span>
      </div>
      <form id="updateModalForm" class="modal-body">
        <label>
          Update note
          <textarea id="updateModalNote" name="note" maxlength="240" placeholder="Share what moved forward or what’s blocked." required></textarea>
        </label>
        <label>
          Status after update
          <select id="updateModalStatus" name="status">
            <option value="">Keep current status</option>
          </select>
        </label>
        <p class="modal-status" id="updateModalMessage" hidden></p>
        <hr class="modal-divider">
        <div class="modal-actions">
          <button type="button" class="btn-ghost" id="updateModalCancel">Cancel</button>
          <button type="submit" id="updateModalSubmit">Save update</button>
        </div>
      </form>
    </div>
  </div>

  <div class="modal-backdrop" id="editTaskModal" hidden>
    <div class="modal-panel" role="dialog" aria-modal="true" aria-labelledby="editTaskModalTitle">
      <div class="modal-header">
        <h3 id="editTaskModalTitle">Edit Task</h3>
        <button type="button" class="modal-close" data-close-modal="editTaskModal" aria-label="Close edit task modal">×</button>
      </div>
      <div class="modal-highlight">
        <span id="editTaskMeta"></span>
      </div>
      <form id="editTaskForm" class="modal-body">
        <label>
          Task title
          <input type="text" id="editTaskTitle" name="title" required maxlength="160" placeholder="Task name">
        </label>
        <label>
          Task details
          <textarea id="editTaskDescription" name="description" maxlength="800" placeholder="Describe the latest scope, links, or references."></textarea>
        </label>
        <label>
          Department
          <select id="editTaskDepartment" name="department">
            <option value="">Select a department...</option>
          </select>
        </label>
        <label>
          Priority
          <select id="editTaskPriority" name="priority">
            <option value="low">Low</option>
            <option value="medium">Medium</option>
            <option value="high">High</option>
          </select>
        </label>
        <label>
          Due date
          <input type="date" id="editTaskDue" name="due">
        </label>
        <label id="editTaskOwnersWrapper">
          Assign to teammates
          <select id="editTaskOwners" name="ownerIds" multiple size="6"></select>
          <span class="modal-hint">Hold Cmd (⌘) or Ctrl to select multiple teammates.</span>
        </label>
        <p class="modal-status" id="editTaskStatus" hidden></p>
        <hr class="modal-divider">
        <div class="modal-actions">
          <button type="button" class="btn-ghost" id="editTaskCancel">Cancel</button>
          <button type="submit" id="editTaskSubmit">Save changes</button>
        </div>
      </form>
    </div>
  </div>

  <div class="modal-backdrop" id="reminderModal" hidden>
    <div class="modal-panel" role="dialog" aria-modal="true" aria-labelledby="reminderModalTitle">
      <div class="modal-header">
        <h3 id="reminderModalTitle">Send Reminder</h3>
        <button type="button" class="modal-close" data-close-modal="reminderModal" aria-label="Close reminder modal">×</button>
      </div>
      <div class="modal-highlight">
        <span id="reminderTaskTitle"></span>
        <span id="reminderTaskMeta"></span>
      </div>
      <form id="reminderModalForm" class="modal-body">
        <label>
          Reminder recipient
          <select id="reminderRecipient" name="recipient">
            <option value="owners">Assigned teammates</option>
            <option value="member">Specific teammate</option>
          </select>
        </label>
        <label id="reminderMemberWrapper" hidden>
          Choose teammate
          <select id="reminderMember"></select>
        </label>
        <label>
          Message
          <textarea id="reminderMessage" name="message" maxlength="320" placeholder="e.g. Posters are due by 6 pm — please share the final export."></textarea>
          <span class="modal-hint">Customize the note that will post to Slack.</span>
        </label>
        <p class="modal-status" id="reminderStatus" hidden></p>
        <hr class="modal-divider">
        <div class="modal-actions">
          <button type="button" class="btn-ghost" id="reminderCancel">Cancel</button>
          <button type="submit" id="reminderSubmit">Send reminder</button>
        </div>
      </form>
    </div>
  </div>

  <div class="modal-backdrop" id="announcementModal" hidden>
    <div class="modal-panel" role="dialog" aria-modal="true" aria-labelledby="announcementModalTitle">
      <div class="modal-header">
        <h3 id="announcementModalTitle">Broadcast Announcement</h3>
        <button type="button" class="modal-close" data-close-modal="announcementModal" aria-label="Close announcement modal">×</button>
      </div>
      <div class="modal-highlight">
        <span>Tagging <!channel> to notify everyone.</span>
      </div>
      <form id="announcementForm" class="modal-body">
        <label>
          Target channel
          <select id="announcementChannel"></select>
        </label>
        <label>
          Message
          <textarea id="announcementMessage" maxlength="400" placeholder="Share meeting links, key updates, or callouts."></textarea>
          <span class="modal-hint">Announcement tags <!channel> so everyone is notified.</span>
        </label>
        <p class="modal-status" id="announcementStatus" hidden></p>
        <hr class="modal-divider">
        <div class="modal-actions">
          <button type="button" class="btn-ghost" id="announcementCancel">Cancel</button>
          <button type="submit" id="announcementSubmit">Send announcement</button>
        </div>
      </form>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('bg-canvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  let width = (canvas.width = window.innerWidth);
  let height = (canvas.height = window.innerHeight);
  const particles = [];
  const pulses = [];

  const random = (min, max) => Math.random() * (max - min) + min;

  const paintStatic = () => {
    const gradient = ctx.createLinearGradient(0, 0, width, height);
    gradient.addColorStop(0, 'rgba(11,16,32,0.18)');
    gradient.addColorStop(1, 'rgba(2,8,18,0.22)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);
  };

  const rebuildParticles = () => {
    particles.length = 0;
    pulses.length = 0;
    const particleCount = Math.max(40, Math.floor((width * height) / 70000));
    for (let i = 0; i < particleCount; i++) {
      particles.push({
        x: random(0, width),
        y: random(0, height),
        r: random(0.6, 2.6),
        vx: random(-0.4, 0.6),
        vy: random(-0.3, 0.4)
      });
    }
    const pulseCount = Math.max(5, Math.floor(width / 280));
    for (let i = 0; i < pulseCount; i++) {
      pulses.push({
        x: random(0, width),
        y: random(0, height),
        radius: random(20, 70),
        alpha: random(0.04, 0.16),
        speed: random(0.3, 0.55)
      });
    }
  };

  const resetPulse = (pulse) => {
    pulse.x = random(0, width);
    pulse.y = random(0, height);
    pulse.radius = random(16, 60);
    pulse.alpha = random(0.04, 0.14);
    pulse.speed = random(0.28, 0.52);
  };

  const resize = () => {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    if (prefersReduced) {
      paintStatic();
    } else {
      rebuildParticles();
    }
  };
  window.addEventListener('resize', resize);

  if (prefersReduced) {
    paintStatic();
    return;
  }

  rebuildParticles();

  const draw = () => {
    ctx.clearRect(0, 0, width, height);
    paintStatic();

    for (const pulse of pulses) {
      pulse.radius += pulse.speed;
      pulse.alpha -= 0.0014;
      if (pulse.alpha <= 0) {
        resetPulse(pulse);
      }
      const gradient = ctx.createRadialGradient(pulse.x, pulse.y, 0, pulse.x, pulse.y, pulse.radius);
      gradient.addColorStop(0, `rgba(123,224,74,${pulse.alpha})`);
      gradient.addColorStop(1, 'rgba(123,224,74,0)');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(pulse.x, pulse.y, pulse.radius, 0, Math.PI * 2);
      ctx.fill();
    }

    for (const particle of particles) {
      particle.x += particle.vx;
      particle.y += particle.vy;
      if (particle.x < -20) particle.x = width + 20;
      if (particle.x > width + 20) particle.x = -20;
      if (particle.y < -20) particle.y = height + 20;
      if (particle.y > height + 20) particle.y = -20;

      ctx.beginPath();
      ctx.fillStyle = `rgba(123,224,74,${0.06 + particle.r / 7})`;
      ctx.shadowColor = 'rgba(123,224,74,0.2)';
      ctx.shadowBlur = 6;
      ctx.arc(particle.x, particle.y, particle.r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.shadowBlur = 0;

    const limit = Math.min(particles.length, 120);
    for (let i = 0; i < limit; i++) {
      const a = particles[i];
      for (let j = i + 1; j < limit; j++) {
        const b = particles[j];
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        const distSq = dx * dx + dy * dy;
        if (distSq < 7800) {
          ctx.beginPath();
          ctx.strokeStyle = `rgba(123,224,74,${0.004 + (7800 - distSq) / 10000})`;
          ctx.lineWidth = 0.7;
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();
        }
      }
    }

    requestAnimationFrame(draw);
  };

  draw();
})();
</script>

<script>
(() => {
  const state = {
    token: null,
    member: null,
    department: null,
    stats: {},
    tasks: [],
    events: [],
    departments: [],
    members: [],
    filters: {
      showMine: false,
      status: 'all',
      department: 'mine'
    },
    people: new Map()
  };
  let lastMemeIndex = -1;
  let activeUpdateTaskId = null;
  let activeReminderTaskId = null;
  let activeEditTaskId = null;
  let createTaskSubmitting = false;
  let updateSubmitting = false;
  let reminderSubmitting = false;
  let editTaskSubmitting = false;
  let announcementSubmitting = false;

  const els = {
    loginPanel: document.getElementById('loginPanel'),
    dashboardPanel: document.getElementById('dashboardPanel'),
    loginForm: document.getElementById('loginForm'),
    loginSubmit: document.getElementById('loginSubmit'),
    loginMessage: document.getElementById('loginMessage'),
    memberName: document.getElementById('memberName'),
    memberMeta: document.getElementById('memberMeta'),
    statsRow: document.getElementById('statsRow'),
    dashboardStatus: document.getElementById('dashboardStatus'),
    taskList: document.getElementById('taskList'),
    eventList: document.getElementById('eventList'),
    logoutBtn: document.getElementById('logoutBtn'),
    refreshBtn: document.getElementById('refreshBtn'),
    departmentFilter: document.getElementById('departmentFilter'),
    myTasksToggle: document.getElementById('myTasksToggle'),
    statusFilter: document.getElementById('statusFilter'),
    newTaskBtn: document.getElementById('newTaskBtn'),
    memePanel: document.getElementById('memePanel'),
    memeText: document.getElementById('memeText'),
    memeAttribution: document.getElementById('memeAttribution'),
    memeShuffle: document.getElementById('memeShuffle'),
    taskModal: document.getElementById('taskModal'),
    taskModalForm: document.getElementById('taskModalForm'),
    taskModalTitle: document.getElementById('taskModalTitle'),
    taskModalDescription: document.getElementById('taskModalDescription'),
    taskModalDepartment: document.getElementById('taskModalDepartment'),
    taskModalDue: document.getElementById('taskModalDue'),
    taskModalStatus: document.getElementById('taskModalStatus'),
    taskModalCancel: document.getElementById('taskModalCancel'),
    taskModalSubmit: document.getElementById('taskModalSubmit'),
    taskModalOwners: document.getElementById('taskModalOwners'),
    taskModalOwnersWrapper: document.getElementById('taskModalOwnersWrapper'),
    updateModal: document.getElementById('updateModal'),
    updateModalForm: document.getElementById('updateModalForm'),
    updateModalNote: document.getElementById('updateModalNote'),
    updateModalStatus: document.getElementById('updateModalStatus'),
    updateModalMessage: document.getElementById('updateModalMessage'),
    updateModalCancel: document.getElementById('updateModalCancel'),
    updateModalSubmit: document.getElementById('updateModalSubmit'),
    updateModalTaskName: document.getElementById('updateModalTaskName'),
    updateModalTaskStatus: document.getElementById('updateModalTaskStatus'),
    editTaskModal: document.getElementById('editTaskModal'),
    editTaskForm: document.getElementById('editTaskForm'),
    editTaskTitle: document.getElementById('editTaskTitle'),
    editTaskDescription: document.getElementById('editTaskDescription'),
    editTaskDepartment: document.getElementById('editTaskDepartment'),
    editTaskOwners: document.getElementById('editTaskOwners'),
    editTaskOwnersWrapper: document.getElementById('editTaskOwnersWrapper'),
    editTaskPriority: document.getElementById('editTaskPriority'),
    editTaskDue: document.getElementById('editTaskDue'),
    editTaskStatus: document.getElementById('editTaskStatus'),
    editTaskCancel: document.getElementById('editTaskCancel'),
    editTaskSubmit: document.getElementById('editTaskSubmit'),
    editTaskMeta: document.getElementById('editTaskMeta'),
    reminderModal: document.getElementById('reminderModal'),
    reminderModalForm: document.getElementById('reminderModalForm'),
    reminderRecipient: document.getElementById('reminderRecipient'),
    reminderMemberWrapper: document.getElementById('reminderMemberWrapper'),
    reminderMember: document.getElementById('reminderMember'),
    reminderMessage: document.getElementById('reminderMessage'),
    reminderStatus: document.getElementById('reminderStatus'),
    reminderCancel: document.getElementById('reminderCancel'),
    reminderSubmit: document.getElementById('reminderSubmit'),
    reminderTaskTitle: document.getElementById('reminderTaskTitle'),
    reminderTaskMeta: document.getElementById('reminderTaskMeta'),
    announcementBtn: document.getElementById('announcementBtn'),
    announcementModal: document.getElementById('announcementModal'),
    announcementForm: document.getElementById('announcementForm'),
    announcementChannel: document.getElementById('announcementChannel'),
    announcementMessage: document.getElementById('announcementMessage'),
    announcementStatus: document.getElementById('announcementStatus'),
    announcementCancel: document.getElementById('announcementCancel'),
    announcementSubmit: document.getElementById('announcementSubmit')
  };

  const identifierInput = els.loginForm?.querySelector('input[name="identifier"]');
  if (identifierInput) {
    identifierInput.addEventListener('input', () => {
      const sanitized = identifierInput.value
        .replace(/[^A-Za-z\s]/g, '')
        .replace(/\s+/g, ' ')
        .replace(/^\s+/, '');
      if (sanitized !== identifierInput.value) {
        identifierInput.value = sanitized;
      }
    });
  }

  if (els.statusFilter) {
    els.statusFilter.value = state.filters.status;
  }
  if (els.myTasksToggle) {
    els.myTasksToggle.checked = state.filters.showMine;
  }

  const indexPerson = (person) => {
    if (!person || typeof person !== 'object' || !person.id) return;
    state.people.set(person.id, {
      id: person.id,
      displayName: person.displayName || person.name || '',
      email: person.email || '',
      role: person.role || '',
      loginId: person.loginId || '',
      departmentId: person.departmentId || ''
    });
  };

  const getRosterMembers = () => {
    const roster = new Map();
    const addMember = (member) => {
      if (!member || typeof member !== 'object') return;
      const id = member.id || member.memberId;
      if (!id) return;
      const existing = roster.get(id) || {};
      roster.set(id, {
        id,
        displayName: member.displayName || existing.displayName || member.name || member.loginId || id,
        loginId: member.loginId || existing.loginId || '',
        email: member.email || existing.email || '',
        role: member.role || existing.role || '',
        departmentId: member.departmentId || existing.departmentId || '',
        slackUserId: member.slackUserId || existing.slackUserId || member.raw?.slack_user_id || ''
      });
    };
    (state.members || []).forEach(addMember);
    state.people.forEach(addMember);
    (state.tasks || []).forEach((task) => {
      (task.owners || []).forEach(addMember);
    });
    return Array.from(roster.values());
  };

  const lookupPerson = (id) => {
    if (!id) return null;
    return state.people.get(id) || null;
  };

  const escapeHTML = (value = '') =>
    String(value)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');

  const getMemberRole = () =>
    (state.member?.roleNormalized || state.member?.role || '').toLowerCase();

  const isElevatedMember = () => {
    const role = getMemberRole();
    return role === 'lead' || role === 'mentor';
  };

  const STATUS_OPTIONS = [
    { value: 'todo', label: 'To do' },
    { value: 'in_progress', label: 'In progress' },
    { value: 'blocked', label: 'Blocked' },
    { value: 'done', label: 'Completed' }
  ];

  let statusMenuEl = null;
  let statusMenuAnchor = null;
  let statusMenuOutsideHandler = null;
  let statusMenuKeyHandler = null;

  const closeStatusMenu = () => {
    if (statusMenuOutsideHandler) {
      document.removeEventListener('click', statusMenuOutsideHandler, true);
      statusMenuOutsideHandler = null;
    }
    if (statusMenuKeyHandler) {
      document.removeEventListener('keydown', statusMenuKeyHandler, true);
      statusMenuKeyHandler = null;
    }
    if (statusMenuEl) {
      statusMenuEl.remove();
      statusMenuEl = null;
    }
    statusMenuAnchor = null;
  };

  const openStatusMenu = (anchorEl, task) => {
    if (!anchorEl || !task) return;
    closeStatusMenu();
    statusMenuAnchor = anchorEl;
    const menu = document.createElement('div');
    menu.className = 'status-menu';
    menu.setAttribute('role', 'menu');
    menu.tabIndex = -1;
    STATUS_OPTIONS.forEach((option) => {
      const item = document.createElement('button');
      item.type = 'button';
      item.className = 'status-menu__item';
      item.dataset.value = option.value;
      if (option.value === task.status) {
        item.classList.add('is-active');
      }
      item.textContent = option.label;
      item.addEventListener('click', async (evt) => {
        evt.preventDefault();
        evt.stopPropagation();
        closeStatusMenu();
        if (option.value === task.status) {
          return;
        }
        try {
          await fetchJSON(`/api/team/tasks/${encodeURIComponent(task.id)}`, {
            method: 'PATCH',
            body: JSON.stringify({ status: option.value })
          });
          setStatus('Task status updated.', 'success');
          await refreshProfile();
          await refreshTasks();
        } catch (err) {
          const errorCode = err.payload?.error || 'update_failed';
          const messages = {
            forbidden: 'You do not have permission to update the status.',
            invalid_status: 'Status must be todo, in_progress, blocked, or done.',
            update_failed: 'Could not update task.'
          };
          setStatus(messages[errorCode] || 'Could not update task.', 'error');
        }
      });
      menu.appendChild(item);
    });
    menu.addEventListener('click', (evt) => evt.stopPropagation());
    menu.style.opacity = '0';
    document.body.appendChild(menu);
    const anchorRect = anchorEl.getBoundingClientRect();
    const menuRect = menu.getBoundingClientRect();
    let left = anchorRect.left + window.scrollX;
    let top = anchorRect.bottom + window.scrollY + 8;
    const maxLeft = window.scrollX + window.innerWidth - menuRect.width - 16;
    const minLeft = window.scrollX + 16;
    if (left > maxLeft) left = Math.max(minLeft, maxLeft);
    if (left < minLeft) left = minLeft;
    const maxTop = window.scrollY + window.innerHeight - menuRect.height - 16;
    const aboveTop = anchorRect.top + window.scrollY - menuRect.height - 8;
    if (top > maxTop) {
      top = Math.max(window.scrollY + 16, aboveTop);
    }
    menu.style.left = `${left}px`;
    menu.style.top = `${top}px`;
    menu.style.opacity = '1';
    statusMenuEl = menu;
    statusMenuOutsideHandler = (evt) => {
      if (!statusMenuEl) return;
      if (statusMenuEl.contains(evt.target) || evt.target === statusMenuAnchor) {
        return;
      }
      closeStatusMenu();
    };
    document.addEventListener('click', statusMenuOutsideHandler, true);
    statusMenuKeyHandler = (evt) => {
      if (evt.key === 'Escape') {
        closeStatusMenu();
      }
    };
    document.addEventListener('keydown', statusMenuKeyHandler, true);
    menu.focus({ preventScroll: true });
  };

  window.addEventListener('scroll', closeStatusMenu, true);
  window.addEventListener('resize', closeStatusMenu, true);

  const MEMES = [
    {
      text: 'Deploying on Fridays? That’s a plot twist, not a roadmap.',
      author: 'Bug Bash Ops'
    },
    {
      text: 'Remember: coffee is just hot bug triage fuel ☕️',
      author: 'Hackathon Pantry Team'
    },
    {
      text: 'QA said “LGTM”, which obviously stands for “Let’s Get The Memes.”',
      author: 'Sprint Standup'
    },
    {
    text: "Teamwork makes the dream work until someone forgets to `git pull`.",
    author: "Geetansh"
    },
    {
    text: "404: Sleep not found since Bug Bash prep began.",
    author: "Insomniac Coders Club"
    },
  ];

  const pickRandomMeme = () => {
    let index = Math.floor(Math.random() * MEMES.length);
    if (index === lastMemeIndex && MEMES.length > 1) {
      index = (index + 1) % MEMES.length;
    }
    lastMemeIndex = index;
    return MEMES[index];
  };

  const renderMeme = () => {
    if (!els.memePanel || !els.memeText || !els.memeAttribution) return;
    const meme = pickRandomMeme();
    els.memeText.textContent = meme.text;
    els.memeAttribution.textContent = meme.author ? `— ${meme.author}` : '';
    els.memePanel.hidden = false;
    requestAnimationFrame(() => els.memePanel.classList.add('is-visible'));
  };

  const reveal = (element) => {
    if (!element) return;
    element.classList.remove('is-visible');
    // Force reflow so animation restarts
    void element.offsetWidth;
    requestAnimationFrame(() => element.classList.add('is-visible'));
  };

  const setToken = (token) => {
    state.token = token;
  };

  const clearStatus = () => {
    els.dashboardStatus.hidden = true;
    els.dashboardStatus.textContent = '';
    els.dashboardStatus.classList.remove('error', 'success');
  };

  const setStatus = (text, type = '') => {
    if (!text) {
      clearStatus();
      return;
    }
    els.dashboardStatus.hidden = false;
    els.dashboardStatus.textContent = text;
    els.dashboardStatus.classList.remove('error', 'success');
    if (type) {
      els.dashboardStatus.classList.add(type);
    }
  };

  const showLoadingPlaceholders = () => {
    if (els.taskList) {
      els.taskList.innerHTML = '<p class="muted">Loading tasks...</p>';
    }
    if (els.eventList) {
      els.eventList.innerHTML = '<p class="muted">Loading events...</p>';
    }
  };

  const setModalMessage = (element, message, type = '') => {
    if (!element) return;
    element.classList.remove('error', 'success');
    if (!message) {
      element.hidden = true;
      element.textContent = '';
      return;
    }
    element.hidden = false;
    element.textContent = message;
    if (type) {
      element.classList.add(type);
    }
  };

  const isModalOpen = (modal) => modal && modal.classList.contains('is-open');

  const openModal = (modal) => {
    if (!modal) return;
    modal.hidden = false;
    requestAnimationFrame(() => modal.classList.add('is-open'));
    document.body.classList.add('modal-open');
  };

  const closeModal = (modal) => {
    if (!modal || modal.hidden) return;
    modal.classList.remove('is-open');
    const finalize = () => {
      modal.hidden = true;
      modal.removeEventListener('transitionend', finalize);
      if (!document.querySelector('.modal-backdrop.is-open')) {
        document.body.classList.remove('modal-open');
      }
    };
    const transitionDuration = parseFloat(getComputedStyle(modal).transitionDuration || '0');
    if (transitionDuration > 0) {
      modal.addEventListener('transitionend', finalize, { once: true });
    } else {
      finalize();
    }
  };

  const registerModalBackdrop = (modal) => {
    if (!modal) return;
    modal.addEventListener('click', (event) => {
      if (event.target === modal) {
        if (modal.id === 'taskModal') {
          closeTaskModal();
        } else if (modal.id === 'updateModal') {
          closeUpdateModalSafe();
        } else if (modal.id === 'editTaskModal') {
          closeEditTaskModal();
        } else if (modal.id === 'reminderModal') {
          closeReminderModal();
        } else {
          closeModal(modal);
        }
      }
    });
  };

  const buildDueDateIso = (value) => {
    if (!value) return '';
    const parts = value.split('-');
    if (parts.length !== 3) return '';
    const [year, month, day] = parts.map((part) => Number.parseInt(part, 10));
    if (!year || !month || !day) return '';
    const date = new Date(Date.UTC(year, month - 1, day, 9, 0, 0));
    if (Number.isNaN(date.getTime())) return '';
    return date.toISOString();
  };

  const formatDateForInput = (value) => {
    if (!value) return '';
    const date = new Date(value);
    if (Number.isNaN(date.getTime())) return '';
    return date.toISOString().slice(0, 10);
  };

  const formatDateForDisplay = (value) => {
    if (!value) return 'No due date';
    const date = new Date(value);
    if (Number.isNaN(date.getTime())) return 'No due date';
    return date.toLocaleDateString('en-IN', {
      day: '2-digit',
      month: 'long',
      year: 'numeric'
    });
  };

  const populateTaskModalDepartments = ({ select = els.taskModalDepartment, selected } = {}) => {
    if (!select) return;
    const previous = select.value;
    const options = [];
    const seen = new Set();
    if (state.department?.id) {
      const label = state.department.name ? `${state.department.name} (My team)` : `My team (${state.department.id})`;
      options.push({ value: state.department.id, label });
      seen.add(state.department.id);
    }
    (state.departments || []).forEach((dept) => {
      if (!dept || typeof dept !== 'object' || !dept.id) return;
      if (seen.has(dept.id)) return;
      options.push({ value: dept.id, label: dept.name || dept.id });
      seen.add(dept.id);
    });
    select.innerHTML = '';
    if (!options.length) {
      const fallback = document.createElement('option');
      fallback.value = '';
      fallback.textContent = 'Departments unavailable';
      select.appendChild(fallback);
      select.disabled = true;
      return;
    }
    select.disabled = false;
    options.forEach((opt) => {
      const optionEl = document.createElement('option');
      optionEl.value = opt.value;
      optionEl.textContent = opt.label;
      select.appendChild(optionEl);
    });
    const allowed = options.map((opt) => opt.value);
    let nextValue = typeof selected === 'string' && allowed.includes(selected) ? selected : previous;
    nextValue = allowed.includes(nextValue) ? nextValue : options[0].value;
    if (!allowed.includes(nextValue)) {
      nextValue = options[0].value;
    }
    select.value = nextValue;
  };

  const getDepartmentName = (deptId) => {
    if (!deptId) return state.department?.name || 'General';
    const match = (state.departments || []).find((dept) => dept.id === deptId);
    if (match?.name) return match.name;
    if (deptId === (state.department?.id || state.member?.departmentId)) {
      return state.department?.name || 'My team';
    }
    return deptId || 'General';
  };

  const populateTaskModalOwners = ({ select = els.taskModalOwners, wrapper = els.taskModalOwnersWrapper, task = null, selectedIds = [] } = {}) => {
    if (!select || !wrapper) return;
    const elevated = isElevatedMember();
    if (!elevated) {
      wrapper.hidden = true;
      select.innerHTML = '';
      select.disabled = true;
      return;
    }
    wrapper.hidden = false;
    select.innerHTML = '';
    select.disabled = false;
    const members = getRosterMembers();
    if (!members.length) {
      const option = document.createElement('option');
      option.disabled = true;
      option.textContent = 'No teammates available yet. Ask admins to add them to the roster.';
      select.appendChild(option);
      select.disabled = true;
      return;
    }
    members.sort((a, b) => {
      const nameA = (a.displayName || a.loginId || a.id || '').toLowerCase();
      const nameB = (b.displayName || b.loginId || b.id || '').toLowerCase();
      return nameA.localeCompare(nameB);
    });
    const grouped = new Map();
    members.forEach((member) => {
      if (!member || !member.id) return;
      const deptId = member.departmentId || '';
      if (!grouped.has(deptId)) {
        grouped.set(deptId, []);
      }
      grouped.get(deptId).push(member);
    });
    const taskDeptId = task?.departmentId || '';
    const deptOrder = [];
    (state.departments || []).forEach((dept) => {
      if (grouped.has(dept.id)) deptOrder.push(dept.id);
    });
    grouped.forEach((_value, deptId) => {
      if (!deptOrder.includes(deptId)) {
        deptOrder.push(deptId);
      }
    });
    deptOrder.forEach((deptId) => {
      const membersInDept = grouped.get(deptId);
      if (!membersInDept || !membersInDept.length) return;
      const optgroup = document.createElement('optgroup');
      const groupLabel = getDepartmentName(deptId);
      optgroup.label = task && deptId === taskDeptId ? `${groupLabel} (Task team)` : groupLabel;
      membersInDept.forEach((member) => {
        const option = document.createElement('option');
        option.value = member.id;
        const baseName = member.displayName || member.loginId || member.id;
        const roleLabel = member.role ? ` • ${member.role}` : '';
        const deptLabel = member.departmentId ? ` • ${getDepartmentName(member.departmentId)}` : '';
        option.textContent = `${baseName}${roleLabel}${deptLabel}`;
        optgroup.appendChild(option);
      });
      select.appendChild(optgroup);
    });
    if (selectedIds.length && !select.disabled) {
      const valueSet = new Set(selectedIds);
      Array.from(select.options).forEach((option) => {
        if (valueSet.has(option.value)) {
          option.selected = true;
        }
      });
    } else if (select.multiple && select.options.length) {
      select.selectedIndex = -1;
    }
  };

  const populateReminderMembers = (task = null, selectedMemberId = '', showWrapper = true) => {
    const wrapper = els.reminderMemberWrapper;
    const select = els.reminderMember;
    if (!wrapper || !select) return;
    const elevated = isElevatedMember();
    if (!elevated) {
      wrapper.hidden = true;
      wrapper.style.display = 'none';
      select.innerHTML = '';
      select.disabled = true;
      return;
    }
    const members = getRosterMembers();
    select.innerHTML = '';
    if (!showWrapper) {
      select.disabled = true;
      wrapper.hidden = true;
      wrapper.style.display = 'none';
      return;
    }
    select.disabled = false;
    wrapper.hidden = false;
    wrapper.style.display = 'block';

    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Select teammate';
    placeholder.disabled = true;
    placeholder.selected = true;
    select.appendChild(placeholder);

    const taskDeptId = task?.departmentId || state.department?.id || state.member?.departmentId || '';
    const inDepartment = members.filter((member) => member?.departmentId === taskDeptId);
    const others = members.filter((member) => member?.departmentId !== taskDeptId);

    const addGroup = (label, items) => {
      if (!items.length) return;
      const optgroup = document.createElement('optgroup');
      optgroup.label = label;
      items
        .filter((member) => member && member.id)
        .sort((a, b) => (a.displayName || a.loginId || a.id || '').localeCompare(b.displayName || b.loginId || b.id || ''))
        .forEach((member) => {
          const option = document.createElement('option');
          option.value = member.id;
          const baseName = member.displayName || member.loginId || member.id;
          const deptLabel = member.departmentId ? ` • ${getDepartmentName(member.departmentId)}` : '';
          option.textContent = `${baseName}${deptLabel}`;
          optgroup.appendChild(option);
        });
      select.appendChild(optgroup);
    };

    addGroup(taskDeptId ? `${getDepartmentName(taskDeptId)} team` : 'My team', inDepartment);
    addGroup('Other teams', others);

    const optionCount = Array.from(select.options).filter((option) => !option.disabled && option.value).length;
    if (!optionCount) {
      const option = document.createElement('option');
      option.disabled = true;
      option.textContent = 'No teammates available.';
      select.appendChild(option);
      select.disabled = true;
      return;
    }
    if (selectedMemberId) {
      const matched = Array.from(select.options).find((option) => option.value === selectedMemberId);
      if (matched) {
        select.value = selectedMemberId;
      }
    }
  };

  const populateAnnouncementChannels = () => {
    const select = els.announcementChannel;
    if (!select) return;
    select.innerHTML = '';
    const options = [];
    options.push({ value: 'global', label: 'All teams (default announcement channel)' });
    (state.departments || []).forEach((dept) => {
      if (!dept || !dept.id) return;
      const channel = dept.channels && typeof dept.channels === 'object' ? dept.channels.slack : '';
      if (!channel || !channel.trim()) return;
      options.push({ value: `department:${dept.id}`, label: `${dept.name || dept.id} channel` });
    });
    if (!options.length) {
      const option = document.createElement('option');
      option.disabled = true;
      option.textContent = 'No announcement channels available.';
      select.appendChild(option);
      select.disabled = true;
      return;
    }
    options.forEach((opt) => {
      const option = document.createElement('option');
      option.value = opt.value;
      option.textContent = opt.label;
      select.appendChild(option);
    });
    select.value = options[0].value;
    select.disabled = false;
  };

  const populateUpdateStatusOptions = () => {
    const select = els.updateModalStatus;
    if (!select || select.dataset.initialized === 'true') return;
    STATUS_OPTIONS.forEach((opt) => {
      const optionEl = document.createElement('option');
      optionEl.value = opt.value;
      optionEl.textContent = opt.label;
      select.appendChild(optionEl);
    });
    select.dataset.initialized = 'true';
  };

  populateTaskModalDepartments();
  populateTaskModalOwners();
  populateReminderMembers();
  populateUpdateStatusOptions();

  const showLogin = (message) => {
    els.dashboardPanel.hidden = true;
    els.dashboardPanel.classList.remove('is-visible');
    els.loginPanel.hidden = false;
    reveal(els.loginPanel);
    if (els.memePanel) {
      els.memePanel.hidden = true;
      els.memePanel.classList.remove('is-visible');
    }
    if (message) {
      els.loginMessage.hidden = false;
      els.loginMessage.textContent = message;
    } else {
      els.loginMessage.hidden = true;
      els.loginMessage.textContent = '';
    }
  };

  const showDashboard = () => {
    els.loginPanel.hidden = true;
    els.loginPanel.classList.remove('is-visible');
    els.dashboardPanel.hidden = false;
    els.loginMessage.hidden = true;
    reveal(els.dashboardPanel);
    if (els.memePanel && !els.memePanel.hidden) {
      reveal(els.memePanel);
    }
  };

  const fetchJSON = async (url, options = {}) => {
    const { skipAuth, ...rest } = options;
    const config = { ...rest };
    config.headers = new Headers(config.headers || {});
    if (config.body && !config.headers.has('Content-Type')) {
      config.headers.set('Content-Type', 'application/json');
    }
    if (!skipAuth && state.token) {
      config.headers.set('Authorization', `Bearer ${state.token}`);
    }
    const response = await fetch(url, config);
    const payload = await response.json().catch(() => ({}));
    if (!response.ok || payload.ok === false) {
      const error = new Error(payload.error || 'request_failed');
      error.response = response;
      error.payload = payload;
      throw error;
    }
    return payload;
  };

  const renderMember = () => {
    if (!state.member) return;
    els.memberName.textContent =
      state.member.displayName || state.member.loginId || state.member.id;
    const deptName = state.department?.name || 'General';
    els.memberMeta.textContent = `${deptName} • ${state.member.role ? state.member.role.toUpperCase() : 'MEMBER'}`;
  };

  const renderStats = () => {
    els.statsRow.innerHTML = '';
    const stats = state.stats || {};
    const statEntries = [
      { label: 'My open tasks', value: stats.myOpenTasks || 0 },
      { label: 'Blocked', value: stats.myBlockedTasks || 0 },
      { label: 'Upcoming events', value: stats.upcomingEvents || 0 }
    ];
    statEntries.forEach((stat) => {
      const pill = document.createElement('div');
      pill.className = 'stat-pill';
      pill.innerHTML = `<strong>${stat.value}</strong><span>${stat.label}</span>`;
      els.statsRow.appendChild(pill);
    });
  };

  const updateDepartmentFilter = () => {
    if (!els.departmentFilter) return;
    const options = [];
    const myTeamLabel = state.department?.name
      ? `My team (${state.department.name})`
      : 'My team';
    options.push({ value: 'mine', label: myTeamLabel });
    options.push({ value: 'all', label: 'All teams' });
    (state.departments || []).forEach((dept) => {
      if (!dept?.id) return;
      options.push({ value: dept.id, label: dept.name || dept.id });
    });

    const previous = state.filters.department;
    els.departmentFilter.innerHTML = '';
    options.forEach((opt) => {
      const optionEl = document.createElement('option');
      optionEl.value = opt.value;
      optionEl.textContent = opt.label;
      els.departmentFilter.appendChild(optionEl);
    });
    const allowed = options.map((opt) => opt.value);
    const nextValue = allowed.includes(previous) ? previous : 'mine';
    els.departmentFilter.value = nextValue;
    state.filters.department = nextValue;
  };

  const formatStatusLabel = (status) => {
    const normalized = (status || 'todo').toLowerCase();
    const match = STATUS_OPTIONS.find((opt) => opt.value === normalized);
    if (match) return match.label;
    return normalized.replace(/_/g, ' ');
  };

  const statusBadge = (status) => {
    const value = (status || 'todo').toLowerCase();
    const label = escapeHTML(formatStatusLabel(value));
    return `<span class="badge status-${value}">${label}</span>`;
  };

  const formatDateTime = (value) => {
    if (!value) return 'No due date';
    const date = new Date(value);
    if (Number.isNaN(date.getTime())) return 'No due date';
    return date.toLocaleString();
  };

  const renderTasks = () => {
    closeStatusMenu();
    els.taskList.innerHTML = '';
    if (!state.tasks.length) {
      const empty = document.createElement('p');
      empty.className = 'muted';
      empty.textContent = 'No tasks match the current filters.';
      els.taskList.appendChild(empty);
      return;
    }
    const memberRole = getMemberRole();
    const isElevated = memberRole === 'lead' || memberRole === 'mentor';
    state.tasks.forEach((task) => {
      const card = document.createElement('article');
      card.className = 'task-card';
      if (task.isMine) card.classList.add('task-card--mine');
      if (!task.hasOwners) card.classList.add('task-card--unassigned');
      if (task.departmentColor) {
        card.style.setProperty('--task-accent', task.departmentColor);
      }
      const title = escapeHTML(task.title || 'Untitled task');
      const description = escapeHTML(task.description || 'No description provided.');
      const departmentName = escapeHTML(task.departmentName || task.departmentId || 'N/A');
      const dueText = escapeHTML(formatDateTime(task.dueAt));
      const priorityRaw = (task.priority || 'medium').replace(/_/g, ' ');
      const priorityLabel = escapeHTML(
        priorityRaw ? priorityRaw.charAt(0).toUpperCase() + priorityRaw.slice(1) : 'Medium'
      );
      const updatesCount = typeof task.updatesCount === 'number' ? task.updatesCount : 0;
      const badges = [statusBadge(task.status)];
      const owners = (task.owners || []).map((owner) => {
        indexPerson(owner);
        const label = escapeHTML(owner.displayName || owner.loginId || owner.id || 'Unknown');
        return `<span class="owner-chip">${label}</span>`;
      });
      const ownersBlock = owners.length ? owners.join('') : '<span class="badge badge--warn">Unassigned</span>';
      const metaItems = [
        `<span><strong>Due:</strong> ${dueText}</span>`,
        `<span><strong>Priority:</strong> ${priorityLabel}</span>`,
        `<span><strong>Updates:</strong> ${escapeHTML(String(updatesCount))}</span>`
      ];
      const actions = [];
      actions.push(`<button class="btn-ghost" data-action="update" data-task="${task.id}">Add update</button>`);
      if (task.lastUpdate?.member) {
        indexPerson(task.lastUpdate.member);
      }
      if (isElevated) {
        actions.push(`<button class="btn-ghost" data-action="edit" data-task="${task.id}">Update status</button>`);
      }
      const canEditTask = typeof task.canEdit === 'boolean' ? task.canEdit : isElevated;
      if (canEditTask) {
        actions.push(`<button class="btn-ghost" data-action="edit-task" data-task="${task.id}">Edit task</button>`);
      }
      if (isElevated) {
        actions.push(`<button class="btn-ghost" data-action="remind" data-task="${task.id}">Send reminder</button>`);
      }
      const canDeleteTask = typeof task.canDelete === 'boolean' ? task.canDelete : isElevated;
      if (canDeleteTask) {
        actions.push(`<button class="btn-ghost" data-action="delete-task" data-task="${task.id}">Delete task</button>`);
      }
      if (task.canClaim) {
        actions.push(`<button class="btn-ghost" data-action="claim" data-task="${task.id}">Assign to me</button>`);
      }
      if (task.canUnclaim && task.isMine) {
        actions.push(`<button class="btn-ghost" data-action="unclaim" data-task="${task.id}">Release task</button>`);
      }
      const assignmentHint =
        !task.hasOwners && task.canClaim
          ? '<p class="assignment-hint">Nobody has picked this yet—claim it to avoid overlaps.</p>'
          : '';
      const lastUpdateBlock = task.lastUpdate
        ? `<div class="task-last-update"><strong>Last update:</strong> ${escapeHTML(task.lastUpdate.note || '')} — ${escapeHTML(task.lastUpdate.member?.displayName || task.lastUpdate.member?.loginId || task.lastUpdate.memberId || '')} (${escapeHTML(formatDateTime(task.lastUpdate.createdAt))})</div>`
        : '';
      card.innerHTML = `
        <h3>
          <span>${title}</span>
          <span class="task-badges">${badges.join(' ')}</span>
        </h3>
        <div class="task-team-tag">Team: ${departmentName}</div>
        <p>${description}</p>
        <div class="task-meta">
          ${metaItems.join('')}
        </div>
        <div class="task-owners">
          ${ownersBlock}
        </div>
        ${lastUpdateBlock}
        ${assignmentHint}
        <div class="task-actions">
          ${actions.join('')}
        </div>
        <details class="task-updates" data-task="${task.id}">
          <summary>View updates</summary>
          <div class="updates-list" data-updates="${task.id}">Loading updates...</div>
        </details>
      `;
      const updatesDetails = card.querySelector(`details.task-updates[data-task="${task.id}"]`);
      if (updatesDetails) {
        updatesDetails.dataset.updatesLoaded = 'false';
        updatesDetails.dataset.updatesLoading = 'false';
        updatesDetails.addEventListener('toggle', () => loadUpdatesIfNeeded(updatesDetails));
        const summaryEl = updatesDetails.querySelector('summary');
        if (summaryEl) {
          summaryEl.addEventListener('click', () =>
            requestAnimationFrame(() => loadUpdatesIfNeeded(updatesDetails))
          );
        }
      }
      els.taskList.appendChild(card);
      requestAnimationFrame(() => card.classList.add('task-card--show'));
    });
  };

  const renderEvents = () => {
    els.eventList.innerHTML = '';
    if (!state.events.length) {
      const empty = document.createElement('p');
      empty.className = 'muted';
      empty.textContent = 'No upcoming events.';
      els.eventList.appendChild(empty);
      return;
    }
    state.events.forEach((event) => {
      const card = document.createElement('article');
      card.className = 'event-card';
      const startDate = event.startAt ? new Date(event.startAt).toLocaleString() : 'TBD';
      const endDate = event.endAt ? new Date(event.endAt).toLocaleString() : '';
      const hostChips = (event.hostMembers || []).map((member) => {
        indexPerson(member);
        const label = escapeHTML(member.displayName || member.loginId || member.id || '');
        return `<span class="owner-chip">${label}</span>`;
      }).join('');
      card.innerHTML = `
        <h4>${escapeHTML(event.title || '')}</h4>
        <p>${escapeHTML(event.description || '')}</p>
        <p><strong>${startDate}</strong>${endDate ? ` → ${endDate}` : ''}</p>
        <p>${escapeHTML(event.location || '')}</p>
        ${hostChips ? `<div class="task-owners">${hostChips}</div>` : ''}
        ${event.link ? `<p><a href="${escapeHTML(event.link)}" target="_blank" rel="noopener noreferrer">Join/Details</a></p>` : ''}
      `;
      els.eventList.appendChild(card);
      requestAnimationFrame(() => card.classList.add('event-card--show'));
    });
  };

  const refreshTasks = async () => {
    const params = new URLSearchParams();
    if (state.filters.showMine) params.set('mine', 'true');
    if (state.filters.status && state.filters.status !== 'all') {
      params.set('status', state.filters.status);
    }
    if (state.filters.department && state.filters.department !== 'all') {
      const deptValue =
        state.filters.department === 'mine'
          ? state.department?.id || state.member?.departmentId
          : state.filters.department;
      if (deptValue) {
        params.set('department', deptValue);
      }
    }
    const query = params.toString();
    const response = await fetchJSON(`/api/team/tasks${query ? `?${query}` : ''}`);
    state.tasks = response.tasks || [];
    state.tasks.forEach((task) => {
      (task.owners || []).forEach(indexPerson);
    });
    renderTasks();
  };

  const resetCreateTaskModal = () => {
    if (els.taskModalTitle) els.taskModalTitle.value = '';
    if (els.taskModalDescription) els.taskModalDescription.value = '';
    if (els.taskModalDue) els.taskModalDue.value = '';
    if (els.taskModalOwners) {
      Array.from(els.taskModalOwners.options || []).forEach((option) => {
        option.selected = false;
      });
    }
    setModalMessage(els.taskModalStatus, '');
    populateTaskModalDepartments();
    populateTaskModalOwners({ task: { departmentId: els.taskModalDepartment?.value || '' } });
  };

  function closeTaskModal() {
    setModalMessage(els.taskModalStatus, '');
    closeModal(els.taskModal);
  }

  function closeEditTaskModal() {
    setModalMessage(els.editTaskStatus, '');
    editTaskSubmitting = false;
    if (els.editTaskSubmit) {
      els.editTaskSubmit.disabled = false;
      els.editTaskSubmit.textContent = 'Save changes';
    }
    activeEditTaskId = null;
    closeModal(els.editTaskModal);
  }

  const openCreateTaskModal = () => {
    if (!els.taskModal) return;
    resetCreateTaskModal();
    openModal(els.taskModal);
    requestAnimationFrame(() => {
      els.taskModalTitle?.focus();
    });
  };

  const openEditTaskModal = (task, { focusField } = {}) => {
    if (!task || !els.editTaskModal) {
      setStatus('Could not load task details.', 'error');
      return;
    }
    activeEditTaskId = task.id;
    setModalMessage(els.editTaskStatus, '');
    if (els.editTaskTitle) {
      els.editTaskTitle.value = task.title || '';
    }
    if (els.editTaskDescription) {
      els.editTaskDescription.value = task.description || '';
    }
    populateTaskModalDepartments({ select: els.editTaskDepartment, selected: task.departmentId || '' });
    populateTaskModalOwners({ select: els.editTaskOwners, wrapper: els.editTaskOwnersWrapper, task, selectedIds: Array.isArray(task.ownerIds) ? task.ownerIds : [] });
    if (els.editTaskPriority) {
      const priorityValue = (task.priority || 'medium').toLowerCase();
      els.editTaskPriority.value = ['low', 'high'].includes(priorityValue) ? priorityValue : 'medium';
    }
    if (els.editTaskDue) {
      els.editTaskDue.value = formatDateForInput(task.dueAt);
    }
    if (els.editTaskSubmit) {
      els.editTaskSubmit.disabled = false;
      els.editTaskSubmit.textContent = 'Save changes';
    }
    if (els.editTaskMeta) {
      const priorityLabel = (task.priority || 'medium').replace(/_/g, ' ');
      const dueLabel = task.dueAt ? formatDateTime(task.dueAt) : 'No due date';
      const ownersLabel = Array.isArray(task.owners) && task.owners.length
        ? task.owners.map((owner) => owner.displayName || owner.loginId || owner.id).join(', ')
        : 'Unassigned';
      els.editTaskMeta.textContent = `${getDepartmentName(task.departmentId || '')} • Priority ${priorityLabel} • Due ${dueLabel} • Owners ${ownersLabel}`;
    }
    openModal(els.editTaskModal);
    requestAnimationFrame(() => {
      if (focusField === 'due') {
        els.editTaskDue?.focus();
      } else {
        els.editTaskTitle?.focus();
      }
    });
  };

  const submitCreateTask = async (event) => {
    event.preventDefault();
    if (createTaskSubmitting) return;
    const title = (els.taskModalTitle?.value || '').trim();
    if (!title) {
      setModalMessage(els.taskModalStatus, 'Give the task a title.', 'error');
      els.taskModalTitle?.focus();
      return;
    }
    const description = (els.taskModalDescription?.value || '').trim();
    const departmentId = (els.taskModalDepartment?.value || '').trim();
    if (!departmentId) {
      setModalMessage(els.taskModalStatus, 'Choose a department for this task.', 'error');
      els.taskModalDepartment?.focus();
      return;
    }
    const dueValue = els.taskModalDue?.value || '';
    const payload = { title, description, departmentId };
    if (dueValue) {
      const dueIso = buildDueDateIso(dueValue);
      if (!dueIso) {
        setModalMessage(els.taskModalStatus, 'Pick a valid due date.', 'error');
        els.taskModalDue?.focus();
        return;
      }
      payload.dueAt = dueIso;
    }
    if (isElevatedMember() && els.taskModalOwners && !els.taskModalOwners.disabled) {
      const selectedOwners = Array.from(els.taskModalOwners.selectedOptions || [])
        .map((option) => option.value)
        .filter(Boolean);
      if (selectedOwners.length) {
        payload.ownerIds = selectedOwners;
      }
    }
    createTaskSubmitting = true;
    if (els.taskModalSubmit) {
      els.taskModalSubmit.disabled = true;
      els.taskModalSubmit.textContent = 'Creating...';
    }
    try {
      await fetchJSON('/api/team/tasks', {
        method: 'POST',
        body: JSON.stringify(payload)
      });
      const elevated = isElevatedMember();
      const successMessage = elevated ? 'Task created.' : 'Task submitted to leads & mentors.';
      closeTaskModal();
      setStatus(successMessage, 'success');
      await refreshProfile();
      await refreshTasks();
    } catch (err) {
      console.error(err);
      const errorCode = err.payload?.error || 'create_failed';
      const messages = {
        missing_title: 'Give the task a title.',
        invalid_owner: 'One of the selected owners is invalid.',
        invalid_department: 'Select a valid department before creating tasks.',
        forbidden: 'You do not have permission to create tasks.',
        create_failed: 'Could not create the task.'
      };
      const message = messages[errorCode] || 'Could not create the task.';
      setModalMessage(els.taskModalStatus, message, 'error');
    } finally {
      createTaskSubmitting = false;
      if (els.taskModalSubmit) {
        els.taskModalSubmit.disabled = false;
        els.taskModalSubmit.textContent = 'Create task';
      }
    }
  };

  const submitEditTask = async (event) => {
    event.preventDefault();
    if (editTaskSubmitting) return;
    if (!activeEditTaskId) {
      setModalMessage(els.editTaskStatus, 'Task is no longer available.', 'error');
      return;
    }
    const task = state.tasks.find((item) => item.id === activeEditTaskId);
    if (!task) {
      setModalMessage(els.editTaskStatus, 'Task is no longer available.', 'error');
      return;
    }
    const payload = {};
    const title = (els.editTaskTitle?.value || '').trim();
    if (!title) {
      setModalMessage(els.editTaskStatus, 'Give the task a title.', 'error');
      els.editTaskTitle?.focus();
      return;
    }
    if (title !== (task.title || '')) {
      payload.title = title;
    }
    const description = (els.editTaskDescription?.value || '').trim();
    if (description !== (task.description || '').trim()) {
      payload.description = description;
    }
    const priorityValue = (els.editTaskPriority?.value || '').trim().toLowerCase();
    if (priorityValue && ['low', 'medium', 'high'].includes(priorityValue)) {
      if (priorityValue !== (task.priority || 'medium').toLowerCase()) {
        payload.priority = priorityValue;
      }
    }
    const departmentId = (els.editTaskDepartment?.value || '').trim();
    if (departmentId && departmentId !== (task.departmentId || '')) {
      payload.departmentId = departmentId;
    }
    const dueValue = els.editTaskDue?.value || '';
    const currentDueInput = formatDateForInput(task.dueAt);
    if ((dueValue || currentDueInput) && dueValue !== currentDueInput) {
      if (dueValue) {
        const dueIso = buildDueDateIso(dueValue);
        if (!dueIso) {
          setModalMessage(els.editTaskStatus, 'Pick a valid due date.', 'error');
          els.editTaskDue?.focus();
          return;
        }
        payload.dueAt = dueIso;
      } else {
        payload.dueAt = '';
      }
    }
    if (els.editTaskOwners && !els.editTaskOwners.disabled) {
      const selectedOwners = Array.from(els.editTaskOwners.selectedOptions || [])
        .map((option) => option.value)
        .filter(Boolean);
      const currentOwners = Array.isArray(task.ownerIds) ? task.ownerIds : [];
      const sameLength = selectedOwners.length === currentOwners.length;
      const sameValues = sameLength && selectedOwners.every((value) => currentOwners.includes(value));
      if (!sameValues) {
        payload.ownerIds = selectedOwners;
      }
    }
    if (!Object.keys(payload).length) {
      setModalMessage(els.editTaskStatus, 'No changes to save.', 'error');
      return;
    }
    editTaskSubmitting = true;
    if (els.editTaskSubmit) {
      els.editTaskSubmit.disabled = true;
      els.editTaskSubmit.textContent = 'Saving...';
    }
    try {
      await fetchJSON(`/api/team/tasks/${encodeURIComponent(activeEditTaskId)}`, {
        method: 'PATCH',
        body: JSON.stringify(payload)
      });
      closeEditTaskModal();
      setStatus('Task updated.', 'success');
      await refreshProfile();
      await refreshTasks();
    } catch (err) {
      console.error(err);
      const errorCode = err.payload?.error || 'update_failed';
      const messages = {
        missing_title: 'Task title cannot be empty.',
        invalid_owner: 'One of the selected teammates is invalid.',
        invalid_department: 'Select a valid department for this task.',
        forbidden: 'You do not have permission to edit this task.',
        update_failed: 'Could not update task.'
      };
      setModalMessage(els.editTaskStatus, messages[errorCode] || 'Could not update task.', 'error');
    } finally {
      editTaskSubmitting = false;
      if (els.editTaskSubmit) {
        els.editTaskSubmit.disabled = false;
        els.editTaskSubmit.textContent = 'Save changes';
      }
    }
  };

function closeUpdateModalSafe() {
  activeUpdateTaskId = null;
  setModalMessage(els.updateModalMessage, '');
  closeModal(els.updateModal);
}

  function closeReminderModal() {
    activeReminderTaskId = null;
    reminderSubmitting = false;
    setModalMessage(els.reminderStatus, '');
    if (els.reminderSubmit) {
      els.reminderSubmit.disabled = false;
      els.reminderSubmit.textContent = 'Send reminder';
    }
    closeModal(els.reminderModal);
  }

  const closeAnnouncementModal = () => {
    announcementSubmitting = false;
    setModalMessage(els.announcementStatus, '');
    if (els.announcementSubmit) {
      els.announcementSubmit.disabled = false;
      els.announcementSubmit.textContent = 'Send announcement';
    }
    if (els.announcementMessage) {
      els.announcementMessage.value = '';
    }
    closeModal(els.announcementModal);
  };

const updateReminderRecipientUI = () => {
  const scope = els.reminderRecipient?.value || 'owners';
  if (!els.reminderMemberWrapper) return;
  const show = scope === 'member';
  els.reminderMemberWrapper.hidden = !show;
  els.reminderMemberWrapper.style.display = show ? 'block' : 'none';
  if (els.reminderMember) {
    els.reminderMember.disabled = !show;
    if (!show) {
      els.reminderMember.value = '';
    }
  }
};

  const openReminderModal = (task) => {
    if (!els.reminderModal || !task) return;
    activeReminderTaskId = task.id;
    setModalMessage(els.reminderStatus, '');
    const owners = Array.isArray(task.ownerIds) ? task.ownerIds : [];
    if (els.reminderRecipient) {
      els.reminderRecipient.value = owners.length ? 'owners' : 'member';
    }
    const showMemberSelect = (els.reminderRecipient?.value || 'owners') === 'member';
    populateReminderMembers(task, showMemberSelect ? owners[0] || '' : '', showMemberSelect);
    updateReminderRecipientUI();
    if (els.reminderTaskTitle) {
      els.reminderTaskTitle.textContent = task.title || 'Untitled task';
    }
    if (els.reminderTaskMeta) {
      const dueLabel = task.dueAt ? formatDateForDisplay(task.dueAt) : 'No due date';
      const priorityLabel = (task.priority || 'medium').replace(/_/g, ' ');
      els.reminderTaskMeta.textContent = `${getDepartmentName(task.departmentId || '')} • Priority ${priorityLabel} • Due ${dueLabel}`;
    }
    if (els.reminderMessage) {
      const defaultMessage = task.dueAt
        ? `Please share an update — this task is due ${formatDateForDisplay(task.dueAt)}.`
        : '';
      els.reminderMessage.value = defaultMessage;
    }
  if (els.reminderSubmit) {
    els.reminderSubmit.disabled = false;
    els.reminderSubmit.textContent = 'Send reminder';
  }
  openModal(els.reminderModal);
};

  const openUpdateModal = (task) => {
    if (!els.updateModal || !task) return;
    activeUpdateTaskId = task.id;
    setModalMessage(els.updateModalMessage, '');
    if (els.updateModalNote) {
      els.updateModalNote.value = '';
    }
    if (els.updateModalStatus) {
      els.updateModalStatus.value = '';
    }
    if (els.updateModalTaskName) {
      els.updateModalTaskName.textContent = task.title || 'Untitled task';
    }
    if (els.updateModalTaskStatus) {
      const label = formatStatusLabel(task.status);
      els.updateModalTaskStatus.textContent = `Status: ${label}`;
    }
    openModal(els.updateModal);
    requestAnimationFrame(() => {
      els.updateModalNote?.focus();
    });
  };

  const submitUpdateModal = async (event) => {
    event.preventDefault();
    if (updateSubmitting) return;
    if (!activeUpdateTaskId) {
      setModalMessage(els.updateModalMessage, 'No task selected for updates.', 'error');
      return;
    }
    const note = (els.updateModalNote?.value || '').trim();
    if (!note) {
      setModalMessage(els.updateModalMessage, 'Write a note before submitting an update.', 'error');
      els.updateModalNote?.focus();
      return;
    }
    if (note.length > 240) {
      setModalMessage(els.updateModalMessage, 'Please keep the update concise (under 240 characters).', 'error');
      return;
    }
    const statusValue = (els.updateModalStatus?.value || '').trim();
    const payload = { note };
    if (statusValue) {
      payload.status = statusValue;
    }
    updateSubmitting = true;
    if (els.updateModalSubmit) {
      els.updateModalSubmit.disabled = true;
      els.updateModalSubmit.textContent = 'Saving...';
    }
    try {
      await fetchJSON(`/api/team/tasks/${encodeURIComponent(activeUpdateTaskId)}/updates`, {
        method: 'POST',
        body: JSON.stringify(payload)
      });
      closeUpdateModalSafe();
      setStatus('Update saved.', 'success');
      await refreshProfile();
      await refreshTasks();
    } catch (err) {
      console.error(err);
      const errorCode = err.payload?.error || 'update_failed';
      const messages = {
        missing_note: 'Write a note before submitting an update.',
        invalid_status: 'Status update not recognised.',
        forbidden: 'You do not have permission to update this task.',
        update_failed: 'Could not save update. Try again.'
      };
      const message = messages[errorCode] || 'Could not save update.';
      setModalMessage(els.updateModalMessage, message, 'error');
    } finally {
      updateSubmitting = false;
      if (els.updateModalSubmit) {
        els.updateModalSubmit.disabled = false;
        els.updateModalSubmit.textContent = 'Save update';
      }
    }
  };

  const submitReminderModal = async (event) => {
    event.preventDefault();
    if (reminderSubmitting) return;
    if (!activeReminderTaskId) {
      setModalMessage(els.reminderStatus, 'Task is no longer available.', 'error');
      return;
    }
    const scope = els.reminderRecipient?.value || 'owners';
    const payload = { scope };
    if (scope === 'member') {
      const memberId = els.reminderMember?.value || '';
      if (!memberId) {
        setModalMessage(els.reminderStatus, 'Choose a teammate for this reminder.', 'error');
        return;
      }
      payload.memberId = memberId;
    }
    const message = (els.reminderMessage?.value || '').trim();
    if (message) {
      payload.message = message;
    }
    reminderSubmitting = true;
    if (els.reminderSubmit) {
      els.reminderSubmit.disabled = true;
      els.reminderSubmit.textContent = 'Sending...';
    }
    try {
      await fetchJSON(`/api/team/tasks/${encodeURIComponent(activeReminderTaskId)}/reminders`, {
        method: 'POST',
        body: JSON.stringify(payload)
      });
      closeReminderModal();
      setStatus('Reminder sent.', 'success');
    } catch (err) {
      console.error(err);
      const errorCode = err.payload?.error || 'reminder_failed';
      const messages = {
        missing_member: 'Pick a teammate to remind.',
        invalid_member: 'Selected teammate could not be found.',
        no_assignees: 'This task does not have any owners yet.',
        invalid_department: 'Department could not be resolved.',
        forbidden: 'You do not have permission to send reminders for this task.',
        reminder_failed: 'Could not send reminder. Try again.'
      };
      setModalMessage(els.reminderStatus, messages[errorCode] || 'Could not send reminder.', 'error');
    } finally {
      reminderSubmitting = false;
      if (els.reminderSubmit) {
        els.reminderSubmit.disabled = false;
        els.reminderSubmit.textContent = 'Send reminder';
      }
    }
  };

  const openAnnouncementModal = () => {
    if (!els.announcementModal) return;
    populateAnnouncementChannels();
    setModalMessage(els.announcementStatus, '');
    if (els.announcementMessage) {
      els.announcementMessage.value = '';
    }
    if (els.announcementSubmit) {
      els.announcementSubmit.disabled = false;
      els.announcementSubmit.textContent = 'Send announcement';
    }
    openModal(els.announcementModal);
    requestAnimationFrame(() => {
      els.announcementMessage?.focus();
    });
  };

  const submitAnnouncement = async (event) => {
    event.preventDefault();
    if (announcementSubmitting) return;
    const message = (els.announcementMessage?.value || '').trim();
    if (!message) {
      setModalMessage(els.announcementStatus, 'Write a message before broadcasting.', 'error');
      els.announcementMessage?.focus();
      return;
    }
    const channelValue = els.announcementChannel?.value || 'global';
    const payload = { message };
    if (channelValue.startsWith('department:')) {
      payload.scope = 'department';
      payload.departmentId = channelValue.slice('department:'.length);
    } else {
      payload.scope = 'global';
    }
    announcementSubmitting = true;
    if (els.announcementSubmit) {
      els.announcementSubmit.disabled = true;
      els.announcementSubmit.textContent = 'Sending...';
    }
    try {
      await fetchJSON('/api/team/announcements', {
        method: 'POST',
        body: JSON.stringify(payload)
      });
      closeAnnouncementModal();
      setStatus('Announcement sent.', 'success');
    } catch (err) {
      console.error(err);
      const errorCode = err.payload?.error || 'announcement_failed';
      const messages = {
        missing_message: 'Write a message before broadcasting.',
        invalid_department: 'Select a valid department channel.',
        missing_channel: 'Slack channel not configured for that department.',
        forbidden: 'Only mentors and leads can send announcements.',
        announcement_failed: 'Could not send announcement.'
      };
      setModalMessage(els.announcementStatus, messages[errorCode] || 'Could not send announcement.', 'error');
    } finally {
      announcementSubmitting = false;
      if (els.announcementSubmit) {
        els.announcementSubmit.disabled = false;
        els.announcementSubmit.textContent = 'Send announcement';
      }
    }
  };

  const refreshEvents = async () => {
    const response = await fetchJSON('/api/team/events');
    let events = Array.isArray(response.events) ? [...response.events] : [];
    const hasLiveHackathon = events.some(
      (event) =>
        typeof event.title === 'string' &&
        event.title.toLowerCase().includes('bugbash hackathon 22nd november')
    );
    if (!hasLiveHackathon) {
      events.unshift({
        id: 'event-bugbash-hackathon-live',
        title: 'BugBash Hackathon – 22 November',
        description: 'Final production push: doors open at 8:00 am, finale showcase 7:00 pm.',
        startAt: '2025-11-22T08:00:00.000Z',
        endAt: '2025-11-22T19:00:00.000Z',
        location: 'SVYASA Main Hall & Labs',
        link: '',
        hosts: [],
        hostMembers: [],
        departmentIds: []
      });
    }
    state.events = events;
    renderEvents();
    if (state.stats) {
      state.stats.upcomingEvents = events.length;
      renderStats();
    }
  };

  const refreshProfile = async () => {
    const response = await fetchJSON('/api/team/me');
    state.member = response.member;
    state.department = response.department;
    state.departments = response.departments || [];
    state.members = Array.isArray(response.members) ? [...response.members] : [];
    state.stats = response.stats || {};
    indexPerson(state.member);
    state.members.forEach(indexPerson);
    renderMember();
    renderStats();
    renderMeme();
    updateDepartmentFilter();
    populateTaskModalDepartments();
    populateTaskModalOwners();
    populateReminderMembers(null, '', false);
    updateReminderRecipientUI();
    populateAnnouncementChannels();
    els.myTasksToggle.checked = state.filters.showMine;
    const memberRole = getMemberRole();
    if (els.newTaskBtn) {
      els.newTaskBtn.hidden = !['lead', 'mentor', 'member'].includes(memberRole);
    }
    if (els.announcementBtn) {
      els.announcementBtn.hidden = !['lead', 'mentor'].includes(memberRole);
    }
  };
  [els.taskModal, els.updateModal, els.editTaskModal, els.reminderModal, els.announcementModal].forEach(registerModalBackdrop);
  document.querySelectorAll('[data-close-modal]').forEach((button) => {
    button.addEventListener('click', () => {
      const targetId = button.dataset.closeModal;
      if (!targetId) return;
      const modal = document.getElementById(targetId);
      if (targetId === 'taskModal') {
        closeTaskModal();
      } else if (targetId === 'updateModal') {
        closeUpdateModalSafe();
      } else if (targetId === 'editTaskModal') {
        closeEditTaskModal();
      } else if (targetId === 'reminderModal') {
        closeReminderModal();
      } else if (targetId === 'announcementModal') {
        closeAnnouncementModal();
      } else {
        closeModal(modal);
      }
    });
  });

  const loadInitialData = async ({ skipReveal = false, statusMessage = 'Loading dashboard...' } = {}) => {
    try {
      if (statusMessage !== null) {
        setStatus(statusMessage);
      }
      await refreshProfile();
      await Promise.all([refreshTasks(), refreshEvents()]);
      setStatus('');
      if (!skipReveal) {
        showDashboard();
      }
    } catch (err) {
      console.error(err);
      const errorCode = err?.payload?.error || '';
      if (errorCode === 'invalid_session' || errorCode === 'unauthorized') {
        setToken(null);
        showLogin('Session expired. Please sign in again.');
        return;
      }
      setStatus('Could not load dashboard. Please try again.', 'error');
    }
  };

  const handleLogin = async (event) => {
    event.preventDefault();
    const formData = new FormData(els.loginForm);
    const identifierRaw = (formData.get('identifier') || '').toString();
    const codeRaw = (formData.get('code') || '').toString();
    const identifier = identifierRaw.trim().replace(/\s+/g, ' ');
    const code = codeRaw.trim();
    if (!identifier || !code) {
      els.loginMessage.hidden = false;
      els.loginMessage.textContent = 'Enter both your name and password.';
      return;
    }
    if (!/^[A-Za-z\s]+$/.test(identifier)) {
      els.loginMessage.hidden = false;
      els.loginMessage.textContent = 'Use letters and spaces only for your name.';
      return;
    }
    els.loginSubmit.disabled = true;
    els.loginSubmit.textContent = 'Signing in...';
    els.loginMessage.hidden = true;
    try {
      const payload = await fetchJSON('/api/team/login', {
        method: 'POST',
        body: JSON.stringify({ email: identifier, code }),
        skipAuth: true
      });
      setToken(payload.token);
      state.member = payload.member;
      state.department = payload.department;
      state.stats = payload.stats || {};
      state.departments = [];
      state.members = [];
      state.tasks = [];
      state.events = [];
      state.people.clear();
      els.loginForm.reset();
      renderMember();
      renderStats();
      renderMeme();
      showLoadingPlaceholders();
      showDashboard();
      setStatus('Loading your workspace...');
      loadInitialData({ skipReveal: true, statusMessage: null });
    } catch (err) {
      const errorCode = err.payload?.error || 'signin_failed';
      const messages = {
        missing_credentials: 'Enter both your name and password.',
        member_not_found: 'We could not find that name. Check the spelling.',
        invalid_credentials: 'Password did not match. Check the latest password.',
        access_not_configured: 'Access for this name is not configured yet.',
        team_dashboard_disabled: 'Team dashboard is disabled right now.',
        signin_failed: 'Sign-in failed. Try again.'
      };
      els.loginMessage.hidden = false;
      els.loginMessage.textContent = messages[errorCode] || 'Could not sign in. Try again.';
    } finally {
      els.loginSubmit.disabled = false;
      els.loginSubmit.textContent = 'Sign in';
    }
  };

  const handleLogout = async () => {
    try {
      await fetchJSON('/api/team/logout', { method: 'POST' });
    } catch (err) {
      console.warn('Logout request failed', err);
    } finally {
      setToken(null);
      state.member = null;
      showLogin('Signed out.');
    }
  };

  const loadUpdatesIfNeeded = async (detailsEl) => {
    if (!detailsEl.open) return;
    if (detailsEl.dataset.updatesLoaded === 'true') return;
    if (detailsEl.dataset.updatesLoading === 'true') return;
    detailsEl.dataset.updatesLoading = 'true';
    const taskId = detailsEl.dataset.task;
    if (!taskId) return;
    const container = detailsEl.querySelector(`[data-updates="${taskId}"]`);
    if (!container) return;
    try {
      container.textContent = 'Loading updates...';
      const response = await fetchJSON(`/api/team/tasks/${encodeURIComponent(taskId)}/updates`);
      const updates = Array.isArray(response.updates) ? [...response.updates] : [];
      const fallbackTask = state.tasks.find((task) => task.id === taskId);
      if (fallbackTask?.lastUpdate) {
        const exists = updates.some((item) => item?.id === fallbackTask.lastUpdate.id);
        if (!exists) {
          updates.unshift({
            id: fallbackTask.lastUpdate.id || 'last-update',
            note: fallbackTask.lastUpdate.note || '',
            statusAfter: fallbackTask.lastUpdate.statusAfter || fallbackTask.lastUpdate.status || '',
            createdAt: fallbackTask.lastUpdate.createdAt || '',
            member: fallbackTask.lastUpdate.member,
            memberId: fallbackTask.lastUpdate.memberId
          });
        }
      }
      if (!updates.length) {
        container.textContent = 'No updates yet.';
        detailsEl.dataset.updatesLoaded = 'true';
        return;
      }
      const markup = updates
        .map((update) => {
          indexPerson(update.member);
          const memberName =
            update.member?.displayName || update.member?.loginId || update.member?.id || 'Unknown';
          const statusText = update.statusAfter
            ? ` • ${escapeHTML(update.statusAfter.replace('_',' '))}`
            : '';
          const timestamp = update.createdAt ? formatDateTime(update.createdAt) : '';
          return `<div class="update-pill"><strong>${escapeHTML(memberName)}${statusText}</strong><span>${escapeHTML(update.note || '')}</span><br/><small>${escapeHTML(timestamp)}</small></div>`;
        })
        .join('');
      container.innerHTML = markup;
      detailsEl.dataset.updatesLoaded = 'true';
    } catch (err) {
      const errorCode = err.payload?.error || '';
      if (errorCode === 'forbidden') {
        container.textContent = 'You do not have permission to view updates on this task.';
      } else {
        container.textContent = 'Could not load updates.';
      }
    } finally {
      detailsEl.dataset.updatesLoading = 'false';
    }
  };

  const handleTaskAction = async (event) => {
    const button = event.target.closest('button[data-action]');
    if (!button) return;
    const action = button.dataset.action;
    const taskId = button.dataset.task;
    if (!taskId) return;
    const task = state.tasks.find((item) => item.id === taskId) || null;
    const elevated = isElevatedMember();
    closeStatusMenu();
    if (action === 'update') {
      if (!task) {
        setStatus('Task could not be found.', 'error');
        return;
      }
      const isOwner =
        Array.isArray(task.ownerIds) && state.member?.id ? task.ownerIds.includes(state.member.id) : false;
      if (!isOwner && !elevated) {
        setStatus('Only task owners and leads or mentors can add updates.', 'error');
        return;
      }
      openUpdateModal(task);
      return;
    }
    if (action === 'edit') {
      if (!elevated) {
        setStatus('Only leads and mentors can update status.', 'error');
        return;
      }
      if (!task) {
        setStatus('Could not load task details.', 'error');
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      openStatusMenu(button, task);
      return;
    }
    if (action === 'edit-task') {
      if (!elevated) {
        setStatus('Only leads and mentors can edit task details.', 'error');
        return;
      }
      openEditTaskModal(task);
      return;
    }
    if (action === 'remind') {
      if (!elevated) {
        setStatus('Only leads and mentors can send reminders.', 'error');
        return;
      }
      if (!task) {
        setStatus('Could not load task details.', 'error');
        return;
      }
      openReminderModal(task);
      return;
    }
    if (action === 'update-deadline') {
      if (!elevated) {
        setStatus('Only leads and mentors can update deadlines.', 'error');
        return;
      }
      openEditTaskModal(task, { focusField: 'due' });
      return;
    }
    if (action === 'delete-task') {
      if (!elevated) {
        setStatus('Only leads and mentors can delete tasks.', 'error');
        return;
      }
      if (!confirm('Delete this task? This action cannot be undone.')) return;
      try {
        await fetchJSON(`/api/team/tasks/${encodeURIComponent(taskId)}`, {
          method: 'DELETE'
        });
        setStatus('Task deleted.', 'success');
        await refreshProfile();
        await refreshTasks();
      } catch (err) {
        const errorCode = err.payload?.error || 'delete_failed';
        const messages = {
          forbidden: 'You do not have permission to delete this task.',
          task_not_found: 'Task was already deleted.',
          delete_failed: 'Could not delete task.'
        };
        setStatus(messages[errorCode] || 'Could not delete task.', 'error');
      }
      return;
    }
    if (action === 'claim' || action === 'unclaim') {
      try {
        await fetchJSON(`/api/team/tasks/${encodeURIComponent(taskId)}/claim`, {
          method: 'POST',
          body: JSON.stringify({ action: action === 'claim' ? 'claim' : 'unclaim' })
        });
        setStatus(
          action === 'claim' ? 'Task assigned to you.' : 'Task released.',
          'success'
        );
        await refreshProfile();
        await refreshTasks();
      } catch (err) {
        const errorCode = err.payload?.error || 'claim_failed';
        const messages = {
          already_claimed: 'Someone already picked this task. Sync with them before joining.',
          not_assigned: 'You are not on this task.',
          forbidden: 'You cannot change assignment on this task.',
          claim_failed: 'Could not update assignment. Try again.'
        };
        setStatus(messages[errorCode] || 'Could not update assignment.', 'error');
      }
    }
  };

  els.loginForm.addEventListener('submit', handleLogin);
  els.logoutBtn.addEventListener('click', handleLogout);
  els.refreshBtn.addEventListener('click', async () => {
    setStatus('Refreshing...');
    await refreshProfile();
    await Promise.all([refreshTasks(), refreshEvents()]);
    setStatus('Refreshed.', 'success');
    setTimeout(clearStatus, 2000);
  });
  if (els.memeShuffle) {
    els.memeShuffle.addEventListener('click', () => {
      renderMeme();
      setStatus('Here’s a fresh meme for the sprint!', 'success');
      setTimeout(clearStatus, 2000);
    });
  }
  els.taskList.addEventListener('click', handleTaskAction);
  els.taskList.addEventListener('toggle', (event) => {
    if (event.target.matches('details.task-updates')) {
      loadUpdatesIfNeeded(event.target);
    }
  });
  els.departmentFilter.addEventListener('change', async (event) => {
    state.filters.department = event.target.value;
    await refreshTasks();
  });
  els.myTasksToggle.addEventListener('change', async (event) => {
    state.filters.showMine = event.target.checked;
    await refreshTasks();
  });
  els.statusFilter.addEventListener('change', async (event) => {
    state.filters.status = event.target.value;
    await refreshTasks();
  });
  els.newTaskBtn.addEventListener('click', openCreateTaskModal);
  if (els.taskModalForm) {
    els.taskModalForm.addEventListener('submit', submitCreateTask);
  }
  if (els.taskModalCancel) {
    els.taskModalCancel.addEventListener('click', closeTaskModal);
  }
  if (els.taskModalDepartment) {
    els.taskModalDepartment.addEventListener('change', () => {
      const selectedOwners = Array.from(els.taskModalOwners?.selectedOptions || [])
        .map((option) => option.value)
        .filter(Boolean);
      const pseudoTask = { departmentId: els.taskModalDepartment.value };
      populateTaskModalOwners({ task: pseudoTask, selectedIds: selectedOwners });
    });
  }
  if (els.updateModalForm) {
    els.updateModalForm.addEventListener('submit', submitUpdateModal);
  }
  if (els.updateModalCancel) {
    els.updateModalCancel.addEventListener('click', closeUpdateModalSafe);
  }
  if (els.editTaskForm) {
    els.editTaskForm.addEventListener('submit', submitEditTask);
  }
  if (els.editTaskCancel) {
    els.editTaskCancel.addEventListener('click', closeEditTaskModal);
  }
  if (els.editTaskDepartment) {
    els.editTaskDepartment.addEventListener('change', () => {
      const selectedOwners = Array.from(els.editTaskOwners?.selectedOptions || [])
        .map((option) => option.value)
        .filter(Boolean);
      const pseudoTask = { departmentId: els.editTaskDepartment.value };
      populateTaskModalOwners({ select: els.editTaskOwners, wrapper: els.editTaskOwnersWrapper, task: pseudoTask, selectedIds: selectedOwners });
    });
  }
  if (els.reminderModalForm) {
    els.reminderModalForm.addEventListener('submit', submitReminderModal);
  }
  if (els.reminderCancel) {
    els.reminderCancel.addEventListener('click', closeReminderModal);
  }
  if (els.reminderRecipient) {
    els.reminderRecipient.addEventListener('change', () => {
      updateReminderRecipientUI();
      if (!isModalOpen(els.reminderModal)) return;
      const task = state.tasks.find((item) => item.id === activeReminderTaskId) || null;
      if (!task) return;
      const owners = Array.isArray(task.ownerIds) ? task.ownerIds : [];
      const isMemberScope = els.reminderRecipient.value === 'member';
      const defaultMember = isMemberScope ? owners[0] || '' : '';
      populateReminderMembers(task, defaultMember, isMemberScope);
    });
  }
  if (els.announcementBtn) {
    els.announcementBtn.addEventListener('click', openAnnouncementModal);
  }
  if (els.announcementForm) {
    els.announcementForm.addEventListener('submit', submitAnnouncement);
  }
  if (els.announcementCancel) {
    els.announcementCancel.addEventListener('click', closeAnnouncementModal);
  }

  document.addEventListener('keydown', (event) => {
    if (event.key !== 'Escape') return;
    if (isModalOpen(els.announcementModal)) {
      closeAnnouncementModal();
      return;
    }
    if (isModalOpen(els.reminderModal)) {
      closeReminderModal();
      return;
    }
    if (isModalOpen(els.editTaskModal)) {
      closeEditTaskModal();
      return;
    }
    if (isModalOpen(els.updateModal)) {
      closeUpdateModalSafe();
      return;
    }
    if (isModalOpen(els.taskModal)) {
      closeTaskModal();
    }
  });

  showLogin();
})();
</script>
</body>
</html>
